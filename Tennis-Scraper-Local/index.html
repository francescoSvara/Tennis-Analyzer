<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tennis Scraper Local</title>
  
  <!-- SVG Icon System (Phosphor-style) -->
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
    <symbol id="icon-tennis" viewBox="0 0 256 256">
      <path fill="currentColor" d="M128 24a104 104 0 1 0 104 104A104.11 104.11 0 0 0 128 24Zm88 104a87.57 87.57 0 0 1-4.28 27.08A88.26 88.26 0 0 0 128 208a87.57 87.57 0 0 1-27.08-4.28 88.26 88.26 0 0 0 0-151.44A87.57 87.57 0 0 1 128 48a88.26 88.26 0 0 0 83.72 52.92 87.57 87.57 0 0 1 4.28 27.08Z"/>
    </symbol>
    <symbol id="icon-download" viewBox="0 0 256 256">
      <path fill="currentColor" d="m213.66 82.34l-56-56A8 8 0 0 0 152 24H56a16 16 0 0 0-16 16v176a16 16 0 0 0 16 16h144a16 16 0 0 0 16-16V88a8 8 0 0 0-2.34-5.66ZM152 88V44l44 44Zm-4 100a8 8 0 0 1-5.66-2.34L128 171.31l-14.34 14.35a8 8 0 0 1-11.32-11.32l24-24a8 8 0 0 1 11.32 0l24 24A8 8 0 0 1 148 188Zm20-28a8 8 0 0 1-8 8h-64a8 8 0 0 1 0-16h64a8 8 0 0 1 8 8Z"/>
    </symbol>
    <symbol id="icon-refresh" viewBox="0 0 256 256">
      <path fill="currentColor" d="M224 128a96 96 0 0 1-94.71 96H128a95.38 95.38 0 0 1-65.94-26.17 8 8 0 1 1 11-11.66A80 80 0 1 0 128 48a79.15 79.15 0 0 0-54 21.29L61.54 80H88a8 8 0 0 1 0 16H40a8 8 0 0 1-8-8V40a8 8 0 0 1 16 0v28.43l14.63-12.94A95.37 95.37 0 0 1 224 128Z"/>
    </symbol>
    <symbol id="icon-check" viewBox="0 0 256 256">
      <path fill="currentColor" d="m229.66 77.66l-128 128a8 8 0 0 1-11.32 0l-56-56a8 8 0 0 1 11.32-11.32L96 188.69l122.34-122.35a8 8 0 0 1 11.32 11.32Z"/>
    </symbol>
    <symbol id="icon-warning" viewBox="0 0 256 256">
      <path fill="currentColor" d="M236.8 188.09L149.35 36.22a24.76 24.76 0 0 0-42.7 0L19.2 188.09a23.51 23.51 0 0 0 0 23.72A24.35 24.35 0 0 0 40.55 224h174.9a24.35 24.35 0 0 0 21.33-12.19 23.51 23.51 0 0 0 .02-23.72ZM120 104a8 8 0 0 1 16 0v40a8 8 0 0 1-16 0Zm8 88a12 12 0 1 1 12-12 12 12 0 0 1-12 12Z"/>
    </symbol>
    <symbol id="icon-database" viewBox="0 0 256 256">
      <path fill="currentColor" d="M128 24c-53.83 0-96 24.6-96 56v96c0 31.4 42.17 56 96 56s96-24.6 96-56V80c0-31.4-42.17-56-96-56Zm0 16c44.45 0 80 19.4 80 40s-35.55 40-80 40s-80-19.4-80-40s35.55-40 80-40Z"/>
    </symbol>
    <symbol id="icon-list" viewBox="0 0 256 256">
      <path fill="currentColor" d="M224 128a8 8 0 0 1-8 8H40a8 8 0 0 1 0-16h176a8 8 0 0 1 8 8ZM40 72h176a8 8 0 0 0 0-16H40a8 8 0 0 0 0 16Zm176 112H40a8 8 0 0 0 0 16h176a8 8 0 0 0 0-16Z"/>
    </symbol>
    <symbol id="icon-clock" viewBox="0 0 256 256">
      <path fill="currentColor" d="M128 24a104 104 0 1 0 104 104A104.11 104.11 0 0 0 128 24Zm0 192a88 88 0 1 1 88-88 88.1 88.1 0 0 1-88 88Zm64-88a8 8 0 0 1-8 8h-56a8 8 0 0 1-8-8V72a8 8 0 0 1 16 0v48h48a8 8 0 0 1 8 8Z"/>
    </symbol>
    <symbol id="icon-trophy" viewBox="0 0 256 256">
      <path fill="currentColor" d="M232 64h-24V48a8 8 0 0 0-8-8H56a8 8 0 0 0-8 8v16H24a16 16 0 0 0-16 16v16a40 40 0 0 0 40 40h2.65A88.14 88.14 0 0 0 120 195.42V216H96a8 8 0 0 0 0 16h64a8 8 0 0 0 0-16h-24v-20.58A88.14 88.14 0 0 0 205.35 136H208a40 40 0 0 0 40-40V80a16 16 0 0 0-16-16Z"/>
    </symbol>
    <symbol id="icon-scan" viewBox="0 0 256 256">
      <path fill="currentColor" d="M224 40v40a8 8 0 0 1-16 0V48h-32a8 8 0 0 1 0-16h40a8 8 0 0 1 8 8ZM80 208H48v-32a8 8 0 0 0-16 0v40a8 8 0 0 0 8 8h40a8 8 0 0 0 0-16Zm136-40a8 8 0 0 0-8 8v32h-32a8 8 0 0 0 0 16h40a8 8 0 0 0 8-8v-40a8 8 0 0 0-8-8ZM40 88a8 8 0 0 0 8-8V48h32a8 8 0 0 0 0-16H40a8 8 0 0 0-8 8v40a8 8 0 0 0 8 8Zm144 96H72a16 16 0 0 1-16-16V88a16 16 0 0 1 16-16h112a16 16 0 0 1 16 16v80a16 16 0 0 1-16 16Z"/>
    </symbol>
  </svg>
  
  <style>
    /* ========== DESIGN TOKENS (Filosofia Frontend) ========== */
    :root {
      /* Motion tokens */
      --duration-fast: 150ms;
      --duration-normal: 250ms;
      --duration-slow: 400ms;
      --ease-premium: cubic-bezier(0.22, 1, 0.36, 1);
      --ease-bounce: cubic-bezier(0.34, 1.56, 0.64, 1);
      
      /* Colors */
      --color-primary: #4caf50;
      --color-primary-dim: rgba(76, 175, 80, 0.2);
      --color-warning: #ffc107;
      --color-warning-dim: rgba(255, 193, 7, 0.2);
      --color-error: #f44336;
      --color-error-dim: rgba(244, 67, 54, 0.2);
      --color-info: #2196f3;
      --color-info-dim: rgba(33, 150, 243, 0.2);
      
      /* Surfaces */
      --surface-card: rgba(255, 255, 255, 0.05);
      --surface-card-hover: rgba(255, 255, 255, 0.08);
      --border-subtle: rgba(255, 255, 255, 0.1);
      
      /* Spacing */
      --radius-sm: 8px;
      --radius-md: 12px;
      --radius-lg: 16px;
      --radius-xl: 20px;
    }
    
    /* Accessibility: Reduced Motion */
    @media (prefers-reduced-motion: reduce) {
      *, *::before, *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
    }
    
    /* ========== RESET & BASE ========== */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      min-height: 100vh;
      color: #fff;
      padding: 20px;
      overflow-x: hidden;
    }
    
    .container {
      max-width: 800px;
      margin: 0 auto;
      width: 100%;
    }
    
    header {
      text-align: center;
      margin-bottom: 30px;
    }
    
    header h1 {
      font-size: 2rem;
      margin-bottom: 8px;
    }
    
    header p {
      color: #888;
      font-size: 0.9rem;
    }
    
    .status-badge {
      display: inline-block;
      padding: 4px 12px;
      border-radius: 20px;
      font-size: 0.75rem;
      margin-top: 10px;
    }
    
    .status-badge.online {
      background: rgba(76, 175, 80, 0.2);
      color: #4caf50;
      border: 1px solid #4caf50;
    }
    
    .status-badge.online::before {
      content: '';
      display: inline-block;
      width: 6px;
      height: 6px;
      background: #4caf50;
      border-radius: 50%;
      margin-right: 6px;
    }
    
    .status-badge.offline {
      background: rgba(244, 67, 54, 0.2);
      color: #f44336;
      border: 1px solid #f44336;
    }
    
    .status-badge.offline::before {
      content: '';
      display: inline-block;
      width: 6px;
      height: 6px;
      background: #f44336;
      border-radius: 50%;
      margin-right: 6px;
    }
    
    .card {
      background: var(--surface-card);
      border-radius: var(--radius-lg);
      padding: 24px;
      margin-bottom: 20px;
      border: 1px solid var(--border-subtle);
      overflow: hidden;
      transition: transform var(--duration-fast) var(--ease-premium),
                  box-shadow var(--duration-fast) var(--ease-premium);
    }
    
    .card:hover {
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
    }
    
    .card h2 {
      font-size: 1.1rem;
      margin-bottom: 16px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    /* Icon component - Phosphor style */
    .icon {
      width: 20px;
      height: 20px;
      flex-shrink: 0;
      transition: transform var(--duration-fast) var(--ease-premium);
    }
    
    .icon-sm { width: 16px; height: 16px; }
    .icon-lg { width: 24px; height: 24px; }
    .icon-xl { width: 28px; height: 28px; }
    
    .form-group {
      display: flex;
      gap: 10px;
    }
    
    input[type="text"] {
      flex: 1;
      padding: 12px 16px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      background: rgba(0, 0, 0, 0.3);
      color: #fff;
      font-size: 1rem;
      min-width: 0;
    }
    
    input[type="text"]::placeholder {
      color: #666;
    }
    
    input[type="text"]:focus {
      outline: none;
      border-color: #4caf50;
    }
    
    button {
      padding: 12px 24px;
      border-radius: var(--radius-sm);
      border: none;
      background: var(--color-primary);
      color: #fff;
      font-size: 1rem;
      font-weight: 500;
      cursor: pointer;
      transition: transform var(--duration-fast) var(--ease-premium),
                  background var(--duration-fast) var(--ease-premium),
                  box-shadow var(--duration-fast) var(--ease-premium);
      white-space: nowrap;
      flex-shrink: 0;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }
    
    button:hover:not(:disabled) {
      background: #45a049;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
    }
    
    button:active:not(:disabled) {
      transform: translateY(0);
    }
    
    button:disabled {
      background: #666;
      cursor: not-allowed;
      opacity: 0.7;
    }
    
    .alert {
      padding: 16px;
      border-radius: 8px;
      margin-top: 16px;
      display: none;
    }
    
    .alert.success {
      background: rgba(76, 175, 80, 0.2);
      border: 1px solid #4caf50;
      color: #a5d6a7;
    }
    
    .alert.error {
      background: rgba(244, 67, 54, 0.2);
      border: 1px solid #f44336;
      color: #ef9a9a;
    }
    
    .alert.warning {
      background: rgba(255, 152, 0, 0.2);
      border: 1px solid #ff9800;
      color: #ffe0b2;
    }
    
    .alert.info {
      background: rgba(33, 150, 243, 0.2);
      border: 1px solid #2196f3;
      color: #90caf9;
    }
    
    .alert.show {
      display: block;
    }
    
    /* Tab system */
    .matches-card-container {
      padding: 0 !important;
      display: flex;
      flex-direction: column;
    }
    
    .tab-header {
      padding: 20px 24px 0;
      border-bottom: 1px solid rgba(76, 175, 80, 0.2);
    }
    
    .tab-header h2 {
      margin-bottom: 16px !important;
    }
    
    .tab-buttons {
      display: flex;
      gap: 0;
      border-bottom: 2px solid rgba(255, 255, 255, 0.05);
      margin: 0 -24px;
      padding: 0 24px;
    }
    
    .tab-btn {
      flex: 1;
      padding: 12px 16px;
      background: transparent;
      border: none;
      color: #999;
      font-size: 0.95rem;
      font-weight: 500;
      cursor: pointer;
      border-bottom: 3px solid transparent;
      transition: color 0.15s ease, border-color 0.15s ease;
      text-align: center;
      white-space: nowrap;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }
    
    .tab-btn:hover {
      color: #ccc;
    }
    
    .tab-btn.active {
      color: #fff;
      border-bottom-color: #4caf50;
    }
    
    .badge {
      background: #4caf50;
      color: #000;
      border-radius: 12px;
      padding: 2px 8px;
      font-size: 0.75rem;
      font-weight: bold;
    }
    
    .badge.badge-red {
      background: #f44336;
      color: #fff;
    }
    
    .tab-content {
      display: none;
      padding: 20px 24px;
      animation: fadeIn 0.15s ease;
    }
    
    .tab-content.active {
      display: block;
    }
    
    @keyframes fadeIn {
      from { opacity: 0.85; }
      to { opacity: 1; }
    }
    
    .stats {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 16px;
    }
    
    .stat-item {
      text-align: center;
      padding: 16px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 8px;
    }
    
    .stat-value {
      font-size: 2rem;
      font-weight: bold;
      color: #4caf50;
    }
    
    .stat-label {
      font-size: 0.85rem;
      color: #888;
      margin-top: 4px;
    }
    
    /* Match list - no overflow-x */
    .matches-list {
      margin-top: 16px;
      max-height: 600px;
      overflow-y: auto;
      scroll-behavior: smooth;
      transition: opacity 0.15s ease;
    }
    
    /* Updating state - solo pointer-events disabilitato, nessun flash visivo */
    .matches-list.updating,
    .missing-list.updating,
    .problematic-list.updating {
      pointer-events: none;
    }
    
    .matches-list::-webkit-scrollbar {
      width: 6px;
    }
    
    .matches-list::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.2);
      border-radius: 3px;
    }
    
    .matches-list::-webkit-scrollbar-thumb {
      background: #4caf50;
      border-radius: 3px;
    }
    
    /* Match item - clickable, symmetric layout */
    .match-item {
      display: grid;
      grid-template-columns: 1fr auto;
      align-items: center;
      gap: 12px;
      padding: 14px 16px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 10px;
      margin-bottom: 10px;
      cursor: pointer;
      transition: background 0.15s ease;
      position: relative;
    }
    
    .match-item:hover {
      background: rgba(76, 175, 80, 0.12);
    }

    .match-item.syncing {
      pointer-events: none;
      opacity: 0.7;
    }

    .match-item.complete {
      cursor: default;
      opacity: 0.7;
      border: 1px solid rgba(76, 175, 80, 0.3);
    }

    .match-item.complete:hover {
      background: rgba(0, 0, 0, 0.2);
      box-shadow: none;
    }

    /* Match action buttons */
    .match-actions {
      display: flex;
      gap: 6px;
      margin-top: 8px;
      justify-content: flex-end;
    }

    .match-action-btn {
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.75rem;
      transition: all 0.15s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 28px;
      height: 24px;
    }

    .match-action-btn.refresh-api-btn {
      background: rgba(76, 175, 80, 0.2);
      border: 1px solid rgba(76, 175, 80, 0.4);
      color: #4caf50;
    }

    .match-action-btn.refresh-api-btn:hover {
      background: rgba(76, 175, 80, 0.4);
      color: #fff;
    }

    .match-action-btn.svg-momentum-btn {
      background: rgba(156, 39, 176, 0.2);
      border: 1px solid rgba(156, 39, 176, 0.4);
      color: #ce93d8;
    }

    .match-action-btn.svg-momentum-btn:hover {
      background: rgba(156, 39, 176, 0.4);
      color: #fff;
    }

    .match-action-btn .icon {
      margin: 0;
    }

    .completeness-badge {
      font-size: 0.7rem;
      padding: 2px 6px;
      border-radius: 4px;
      color: #fff;
      font-weight: bold;
    }
    
    /* Progress bar completezza */
    .completeness-bar {
      width: 60px;
      height: 4px;
      background: rgba(255,255,255,0.1);
      border-radius: 2px;
      overflow: hidden;
      margin-top: 4px;
    }
    
    .completeness-bar-fill {
      height: 100%;
      border-radius: 2px;
      transition: width 0.2s ease;
    }
    
    /* Icone SVG inline */
    .icon {
      width: 16px;
      height: 16px;
      vertical-align: middle;
      margin-right: 4px;
    }
    
    .icon-sm {
      width: 12px;
      height: 12px;
    }
    
    .match-item .match-left {
      min-width: 0;
      overflow: hidden;
    }
    
    .match-item .match-right {
      text-align: right;
      flex-shrink: 0;
    }
    
    .match-players {
      font-weight: 500;
      font-size: 0.95rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }
    
    .match-score {
      font-weight: bold;
      color: #4caf50;
      font-size: 0.9rem;
      background: rgba(76, 175, 80, 0.15);
      padding: 2px 8px;
      border-radius: 4px;
    }
    
    .match-tournament {
      font-size: 0.8rem;
      color: #888;
      margin-top: 4px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .match-date {
      font-size: 0.75rem;
      color: #666;
    }
    
    .match-status {
      font-size: 0.7rem;
      padding: 3px 8px;
      border-radius: 4px;
      display: inline-block;
      margin-top: 4px;
    }
    
    /* Ended - Verde */
    .match-status.ended {
      background: rgba(76, 175, 80, 0.2);
      color: #4caf50;
    }
    
    /* Live - Rosso pulsante sottile */
    .match-status.live {
      background: rgba(244, 67, 54, 0.2);
      color: #f44336;
      animation: pulse 2s ease-in-out infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    
    /* Not started - Rosso */
    .match-status.notstarted {
      background: rgba(244, 67, 54, 0.2);
      color: #f44336;
    }
    
    /* Cancelled - Rosso */
    .match-status.cancelled,
    .match-status.canceled {
      background: rgba(244, 67, 54, 0.2);
      color: #f44336;
    }
    
    /* Retired / Walkover / Postponed - Grigio */
    .match-status.retired,
    .match-status.walkover,
    .match-status.postponed,
    .match-status.interrupted {
      background: rgba(158, 158, 158, 0.2);
      color: #9e9e9e;
    }
    
    /* Fallback per altri status finiti */
    .match-status.finished {
      background: rgba(76, 175, 80, 0.2);
      color: #4caf50;
    }
    
    /* Mini loader for match sync */
    .match-loader {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: flex;
      align-items: center;
      gap: 8px;
      background: rgba(0, 0, 0, 0.8);
      padding: 8px 16px;
      border-radius: 8px;
      z-index: 10;
    }
    
    .match-loader .mini-spinner {
      width: 16px;
      height: 16px;
      border: 2px solid #4caf50;
      border-top-color: transparent;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
    
    .match-loader span {
      font-size: 0.8rem;
      color: #4caf50;
    }
    
    .loading {
      text-align: center;
      padding: 20px;
      color: #888;
    }
    
    .spinner {
      display: inline-block;
      width: 16px;
      height: 16px;
      border: 2px solid #4caf50;
      border-top-color: transparent;
      border-radius: 50%;
      animation: spin 0.6s linear infinite;
      margin-right: 6px;
      vertical-align: middle;
    }
    
    /* Loader circolare per bottone */
    .btn-loader {
      display: inline-block;
      width: 16px;
      height: 16px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-top-color: #fff;
      border-radius: 50%;
      animation: spin 0.6s linear infinite;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Skeleton shimmer - Filosofia: loading sottile */
    .skeleton {
      background: linear-gradient(90deg,
        rgba(255,255,255,0.04) 0%,
        rgba(255,255,255,0.08) 50%,
        rgba(255,255,255,0.04) 100%);
      background-size: 200% 100%;
      animation: shimmer 1.2s ease-in-out infinite;
      border-radius: 6px;
    }
    
    @keyframes shimmer {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }
    
    .skeleton-card {
      padding: 14px 16px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 10px;
      margin-bottom: 10px;
    }
    
    .skeleton-line {
      height: 14px;
      margin-bottom: 8px;
      border-radius: 4px;
    }
    
    .skeleton-line.short { width: 40%; }
    .skeleton-line.medium { width: 65%; }
    .skeleton-line.long { width: 85%; }
    
    .skeleton-stat {
      height: 32px;
      width: 60px;
      margin: 0 auto 4px;
    }
    
    .info-box {
      background: rgba(33, 150, 243, 0.1);
      border: 1px solid #2196f3;
      border-radius: 8px;
      padding: 16px;
      margin-bottom: 20px;
    }
    
    .info-box h3 {
      color: #64b5f6;
      margin-bottom: 8px;
      font-size: 0.9rem;
    }
    
    .info-box p {
      color: #90caf9;
      font-size: 0.85rem;
      line-height: 1.5;
    }
    
    /* Pagination styles */
    .pagination {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 12px;
      margin-top: 20px;
      padding-top: 16px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      flex-wrap: wrap;
    }
    
    .pagination button {
      padding: 8px 16px;
      font-size: 0.85rem;
      background: rgba(76, 175, 80, 0.2);
      border: 1px solid #4caf50;
    }
    
    .pagination button:hover:not(:disabled) {
      background: rgba(76, 175, 80, 0.4);
    }
    
    .pagination button:disabled {
      background: rgba(100, 100, 100, 0.2);
      border-color: #666;
      color: #666;
    }
    
    .pagination .page-info {
      color: #888;
      font-size: 0.8rem;
      text-align: center;
    }
    
    /* Container card partite mancanti - bordo giallo */
    .missing-card-container {
      background: rgba(255, 193, 7, 0.05);
      border: 2px solid rgba(255, 193, 7, 0.4);
    }
    
    .missing-card-container h2 {
      color: #ffc107;
    }
    
    .missing-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    
    .btn-scan {
      padding: 6px 12px;
      font-size: 0.8rem;
      background: rgba(255, 193, 7, 0.2);
      border: 1px solid rgba(255, 193, 7, 0.5);
      color: #ffc107;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .btn-scan:hover:not(:disabled) {
      background: rgba(255, 193, 7, 0.3);
    }
    
    .btn-scan:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .source-info {
      font-size: 0.75rem;
      color: #888;
    }
    
    .tournament-info {
      color: #888;
      font-size: 0.85rem;
      margin: 0;
    }
    
    .missing-list {
      max-height: 400px;
      overflow-y: auto;
    }
    
    .missing-list::-webkit-scrollbar {
      width: 6px;
    }
    
    .missing-list::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.2);
      border-radius: 3px;
    }
    
    .missing-list::-webkit-scrollbar-thumb {
      background: #ffc107;
      border-radius: 3px;
    }
    
    /* Card singola partita mancante - giallo coerente come match recenti */
    .missing-match-card {
      display: grid;
      grid-template-columns: 1fr auto;
      align-items: center;
      gap: 12px;
      padding: 14px 16px;
      background: rgba(255, 193, 7, 0.1);
      border: 1px solid rgba(255, 193, 7, 0.3);
      border-radius: 10px;
      margin-bottom: 10px;
      cursor: pointer;
      transition: background 0.15s ease;
    }
    
    .missing-match-card:hover {
      background: rgba(255, 193, 7, 0.18);
    }
    
    .missing-match-card .card-left {
      min-width: 0;
    }
    
    .missing-match-card .card-right {
      text-align: right;
    }
    
    .missing-match-card .players {
      font-weight: 500;
      font-size: 0.95rem;
      color: #fff;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .missing-match-card .round-info {
      font-size: 0.8rem;
      color: #888;
      margin-top: 4px;
    }
    
    .missing-match-card .status-badge {
      font-size: 0.7rem;
      padding: 3px 8px;
      border-radius: 4px;
      background: rgba(255, 193, 7, 0.2);
      color: #ffc107;
      display: inline-block;
    }
    
    .missing-match-card .date-info {
      font-size: 0.75rem;
      color: #666;
      margin-top: 4px;
    }

    /* Animazione copia */
    .missing-match-card.copied {
      background: rgba(76, 175, 80, 0.3) !important;
      border-color: rgba(76, 175, 80, 0.6) !important;
      transform: scale(0.98);
    }
    
    /* Animazione rimozione card - sottile */
    .missing-match-card {
      transition: opacity 0.2s ease, transform 0.2s ease;
    }
    
    .missing-match-card.removing {
      opacity: 0;
      transform: translateX(20px);
      pointer-events: none;
    }
    
    /* Toast notification - motion sottile */
    .copy-toast {
      position: fixed;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%) translateY(20px);
      background: rgba(76, 175, 80, 0.95);
      color: white;
      padding: 10px 18px;
      border-radius: 8px;
      font-size: 0.85rem;
      font-weight: 500;
      box-shadow: 0 2px 12px rgba(0, 0, 0, 0.3);
      z-index: 10000;
      opacity: 0;
      transition: opacity 0.2s ease, transform 0.2s ease;
      max-width: 90%;
      text-align: center;
    }
    
    .copy-toast.show {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }

    /* Mobile responsive */
    @media (max-width: 600px) {
      body {
        padding: 12px;
      }
      
      header h1 {
        font-size: 1.5rem;
      }
      
      header p {
        font-size: 0.8rem;
      }
      
      .card {
        padding: 16px;
      }
      
      .card h2 {
        font-size: 1rem;
      }
      
      .form-group {
        flex-direction: column;
      }
      
      .form-group button {
        width: 100%;
      }
      
      .stats {
        grid-template-columns: 1fr 1fr;
        gap: 12px;
      }
      
      .stat-item {
        padding: 12px 8px;
      }
      
      .stat-value {
        font-size: 1.5rem;
      }
      
      .stat-label {
        font-size: 0.75rem;
      }
      
      .match-item {
        padding: 12px;
        gap: 8px;
      }
      
      .match-players {
        font-size: 0.85rem;
      }
      
      .match-score {
        font-size: 0.8rem;
        padding: 2px 6px;
      }
      
      .match-tournament {
        font-size: 0.75rem;
      }
      
      .match-date {
        font-size: 0.7rem;
      }
      
      .match-status {
        font-size: 0.65rem;
        padding: 2px 6px;
      }
      
      .pagination {
        gap: 8px;
      }
      
      .pagination button {
        padding: 6px 12px;
        font-size: 0.8rem;
      }
      
      .pagination .page-info {
        font-size: 0.75rem;
        width: 100%;
        order: -1;
      }
      
      .info-box {
        padding: 12px;
      }
      
      .info-box h3 {
        font-size: 0.85rem;
      }
      
      .info-box p {
        font-size: 0.8rem;
      }
      
      .missing-section {
        padding: 12px;
      }
      
      .missing-item {
        padding: 8px 10px;
      }
      
      .missing-item .missing-teams {
        font-size: 0.8rem;
      }
      
      .modal .modal-content {
        width: 95%;
        margin: 10px;
      }
    }
    
    /* Modal styles */
    body.modal-open {
      overflow: hidden !important;
    }

    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      padding: 20px;
      backdrop-filter: blur(4px);
      overflow-y: auto;
    }
    
    .modal-content {
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      border-radius: 16px;
      width: 100%;
      max-width: 480px;
      border: 1px solid rgba(76, 175, 80, 0.3);
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5), 0 0 40px rgba(76, 175, 80, 0.1);
      animation: modalSlideIn 0.3s ease;
      display: flex;
      flex-direction: column;
      max-height: 90vh;
    }
    
    @keyframes modalSlideIn {
      from {
        opacity: 0;
        transform: translateY(-8px) scale(0.98);
      }
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }
    
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: rgba(0, 0, 0, 0.2);
      padding: 18px 24px;
      border-bottom: 1px solid rgba(76, 175, 80, 0.2);
    }
    
    .modal-header h3 {
      margin: 0;
      font-size: 1.15rem;
      color: #fff;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .modal-close {
      font-size: 1.8rem;
      cursor: pointer;
      color: #666;
      transition: all 0.2s;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 8px;
    }
    
    .modal-close:hover {
      color: #f44336;
      background: rgba(244, 67, 54, 0.1);
    }
    
    .modal-body {
      padding: 24px;
    }
    
    .modal-body p {
      margin-bottom: 20px;
      color: #ccc;
      line-height: 1.6;
      background: rgba(0, 0, 0, 0.2);
      padding: 16px;
      border-radius: 10px;
      border-left: 3px solid #4caf50;
    }
    
    .modal-body p strong {
      color: #4caf50;
      display: block;
      margin-bottom: 8px;
    }
    
    .modal-body p small {
      color: #888;
      font-size: 0.85rem;
    }
    
    .modal-body input {
      width: 100%;
      padding: 14px 18px;
      border-radius: 10px;
      border: 2px solid rgba(255, 255, 255, 0.1);
      background: rgba(0, 0, 0, 0.3);
      color: #fff;
      font-size: 0.95rem;
      margin-bottom: 16px;
      transition: all 0.2s;
    }
    
    .modal-body input:focus {
      outline: none;
      border-color: #4caf50;
      box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.2);
    }
    
    .modal-body input::placeholder {
      color: #666;
    }
    
    .modal-validation {
      padding: 12px 16px;
      border-radius: 10px;
      font-size: 0.9rem;
      min-height: 24px;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: opacity 0.15s ease;
    }
    
    .modal-validation:empty {
      display: none;
    }
    
    .modal-validation.success {
      background: rgba(76, 175, 80, 0.15);
      color: #4caf50;
      border: 1px solid rgba(76, 175, 80, 0.3);
    }
    
    .modal-validation.warning {
      background: rgba(255, 152, 0, 0.15);
      color: #ff9800;
      border: 1px solid rgba(255, 152, 0, 0.3);
    }
    
    .modal-validation.error {
      background: rgba(244, 67, 54, 0.15);
      color: #f44336;
      border: 1px solid rgba(244, 67, 54, 0.3);
    }
    
    .modal-footer {
      display: flex;
      justify-content: flex-end;
      gap: 12px;
      padding: 18px 24px;
      background: rgba(0, 0, 0, 0.2);
      border-top: 1px solid rgba(255, 255, 255, 0.05);
    }
    
    .modal-footer button {
      padding: 12px 24px;
      border-radius: 10px;
      font-weight: 600;
      transition: all 0.2s;
    }
    
    .modal-footer .btn-cancel {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: #ccc;
    }
    
    .modal-footer .btn-cancel:hover {
      background: rgba(255, 255, 255, 0.1);
      color: #fff;
    }
    
    .modal-footer button:not(.btn-cancel) {
      background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
      border: none;
    }
    
    .modal-footer button:not(.btn-cancel):hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
    }
    
    .modal-footer button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }
    
    /* Missing item additional styles */
    .missing-item {
      display: grid;
      grid-template-columns: 1fr auto;
      align-items: center;
    }
    
    .missing-left {
      min-width: 0;
    }
    
    .missing-info {
      font-size: 0.75rem;
      color: #888;
      margin-top: 2px;
    }
    
    .missing-right {
      text-align: right;
    }
    
    /* Stats Summary Card */
    .stats-summary-card {
      padding: 16px 24px !important;
      margin-bottom: 16px;
    }
    
    .stats-summary {
      display: flex;
      justify-content: space-around;
      align-items: center;
      gap: 20px;
    }
    
    .stats-row-main {
      padding-bottom: 12px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .stats-row-secondary {
      padding-top: 12px;
      gap: 30px;
    }
    
    .stat-box {
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      gap: 4px;
    }
    
    .stat-box .stat-icon {
      width: 20px;
      height: 20px;
      opacity: 0.8;
      margin-bottom: 2px;
    }

    .stat-box-highlight {
      background: rgba(76, 175, 80, 0.1);
      padding: 8px 16px;
      border-radius: 8px;
      border: 1px solid rgba(76, 175, 80, 0.3);
    }

    .stat-box .stat-number {
      font-size: 1.8rem;
      font-weight: bold;
      color: #4caf50;
      position: relative;
      display: inline-flex;
      overflow: hidden;
    }

    /* Flip Clock Effect */
    .flip-digit {
      display: inline-block;
      position: relative;
      width: 0.65em;
      height: 1.2em;
      line-height: 1.2em;
      text-align: center;
      perspective: 300px;
    }

    .flip-digit .digit-current,
    .flip-digit .digit-next {
      position: absolute;
      left: 0;
      right: 0;
      background: linear-gradient(180deg, rgba(30,30,50,0.9) 0%, rgba(20,20,40,0.9) 49%, rgba(40,40,60,0.9) 51%, rgba(25,25,45,0.9) 100%);
      border-radius: 4px;
      backface-visibility: hidden;
    }

    .flip-digit .digit-current {
      z-index: 2;
    }

    .flip-digit .digit-next {
      z-index: 1;
      transform: rotateX(180deg);
    }

    .flip-digit.flipping .digit-current {
      animation: flipTop 0.4s ease-in forwards;
    }

    .flip-digit.flipping .digit-next {
      animation: flipBottom 0.4s ease-out 0.2s forwards;
    }

    @keyframes flipTop {
      0% { transform: rotateX(0deg); }
      100% { transform: rotateX(-90deg); }
    }

    @keyframes flipBottom {
      0% { transform: rotateX(90deg); }
      100% { transform: rotateX(0deg); }
    }

    /* Shimmer sottile su cambio numero */
    .stat-number.updating {
      animation: numShimmer 0.3s ease-out;
    }

    @keyframes numShimmer {
      0% { text-shadow: 0 0 6px rgba(76, 175, 80, 0.6); }
      100% { text-shadow: none; }
    }

    /* Roll animation sottile */
    .stat-number .roll-digit {
      display: inline-block;
      animation: rollIn 0.25s ease-out;
    }

    @keyframes rollIn {
      0% {
        transform: translateY(-50%);
        opacity: 0;
      }
      100% {
        transform: translateY(0);
        opacity: 1;
      }
    }

    .stat-box .stat-percent {
      font-size: 0.85rem;
      color: #ffc107;
      font-weight: 600;
      transition: transform 0.3s ease, opacity 0.3s ease;
    }
    
    .stat-box .stat-label {
      font-size: 0.7rem;
      color: #888;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-top: 2px;
    }
    
    .stat-box-small {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .stat-label-small {
      font-size: 0.75rem;
      color: #888;
    }
    
    .stat-value-small {
      font-size: 0.9rem;
      font-weight: bold;
      color: #64b5f6;
    }
    
    @media (max-width: 600px) {
      .stats-summary {
        flex-wrap: wrap;
        gap: 12px;
      }
      
      .stat-box .stat-number {
        font-size: 1.4rem;
      }
      
      .stat-box .stat-label {
        font-size: 0.65rem;
      }
    }

    /* Completeness Tiers Row */
    .stats-row-completeness {
      display: flex;
      justify-content: space-around;
      align-items: center;
      gap: 10px;
      padding-top: 12px;
      flex-wrap: wrap;
    }

    .completeness-tier {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 8px 12px;
      border-radius: 8px;
      background: rgba(0, 0, 0, 0.2);
      min-width: 55px;
    }

    .completeness-tier[data-tier="100"] {
      background: rgba(76, 175, 80, 0.15);
      border: 1px solid rgba(76, 175, 80, 0.4);
    }

    .completeness-tier[data-tier="90"] {
      background: rgba(139, 195, 74, 0.15);
      border: 1px solid rgba(139, 195, 74, 0.4);
    }

    .completeness-tier[data-tier="80"] {
      background: rgba(255, 193, 7, 0.15);
      border: 1px solid rgba(255, 193, 7, 0.4);
    }

    .completeness-tier[data-tier="50"] {
      background: rgba(255, 152, 0, 0.15);
      border: 1px solid rgba(255, 152, 0, 0.4);
    }

    .completeness-tier[data-tier="under50"] {
      background: rgba(244, 67, 54, 0.15);
      border: 1px solid rgba(244, 67, 54, 0.4);
    }

    .tier-value {
      font-size: 1.2rem;
      font-weight: bold;
      color: #fff;
    }

    .completeness-tier[data-tier="100"] .tier-value { color: #4caf50; }
    .completeness-tier[data-tier="90"] .tier-value { color: #8bc34a; }
    .completeness-tier[data-tier="80"] .tier-value { color: #ffc107; }
    .completeness-tier[data-tier="50"] .tier-value { color: #ff9800; }
    .completeness-tier[data-tier="under50"] .tier-value { color: #f44336; }

    .tier-label {
      font-size: 0.65rem;
      color: #888;
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }

    /* Problematic Matches Section */
    .problematic-info-text {
      font-size: 0.85rem;
      color: #888;
      margin: 0 0 12px 0;
      padding: 8px 12px;
      background: rgba(244, 67, 54, 0.08);
      border-radius: 6px;
      border-left: 3px solid #f44336;
    }

    .problematic-card {
      border: 2px solid rgba(244, 67, 54, 0.4);
      background: rgba(244, 67, 54, 0.05);
      margin-bottom: 16px;
    }

    .problematic-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
      flex-wrap: wrap;
      gap: 8px;
    }

    .problematic-header h3 {
      margin: 0;
      color: #f44336;
      font-size: 1rem;
    }

    .problematic-info {
      font-size: 0.75rem;
      color: #888;
    }

    .problematic-list {
      max-height: 250px;
      overflow-y: auto;
    }

    .problematic-list::-webkit-scrollbar {
      width: 4px;
    }

    .problematic-list::-webkit-scrollbar-thumb {
      background: #f44336;
      border-radius: 2px;
    }

    .problematic-match {
      display: grid;
      grid-template-columns: 1fr auto;
      align-items: center;
      padding: 10px 12px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 8px;
      margin-bottom: 8px;
      gap: 10px;
    }

    .problematic-match .match-info {
      min-width: 0;
    }

    .problematic-match .players {
      font-size: 0.9rem;
      font-weight: 500;
      color: #fff;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .problematic-match .meta {
      font-size: 0.75rem;
      color: #888;
      margin-top: 2px;
    }

    .problematic-match .stats {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 2px;
    }

    .problematic-match .days-old {
      font-size: 0.7rem;
      color: #f44336;
      padding: 2px 6px;
      background: rgba(244, 67, 54, 0.2);
      border-radius: 4px;
    }

    .problematic-match .refresh-count {
      font-size: 0.65rem;
      color: #888;
    }

    .problematic-match .refresh-btn {
      background: rgba(244, 67, 54, 0.3);
      border: 1px solid rgba(244, 67, 54, 0.5);
      color: #f44336;
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: all 0.15s ease;
    }

    .problematic-match .refresh-btn:hover {
      background: rgba(244, 67, 54, 0.5);
      color: #fff;
    }

    .problematic-match .refresh-btn.loading {
      opacity: 0.5;
      pointer-events: none;
    }

    .problematic-match .stats {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    @media (max-width: 600px) {
      .stats-row-completeness {
        gap: 6px;
      }
      
      .completeness-tier {
        padding: 6px 8px;
        min-width: 45px;
      }
      
      .tier-value {
        font-size: 1rem;
      }
    }

    /* SVG Momentum Modal Styles */
    .svg-momentum-modal .svg-modal-content {
      max-width: 600px;
      max-height: 90vh;
      display: flex;
      flex-direction: column;
    }

    .svg-momentum-modal .svg-modal-body {
      flex: 1;
      overflow-y: auto;
      min-height: 0;
    }

    .svg-momentum-modal .svg-modal-footer {
      flex-shrink: 0;
      position: sticky;
      bottom: 0;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      border-top: 1px solid rgba(156, 39, 176, 0.3);
      padding: 16px 24px;
      display: flex;
      justify-content: flex-end;
      gap: 12px;
    }

    .svg-modal-header {
      background: linear-gradient(135deg, rgba(156, 39, 176, 0.2), rgba(103, 58, 183, 0.2)) !important;
      border-bottom-color: rgba(156, 39, 176, 0.3) !important;
      flex-shrink: 0;
    }

    .svg-modal-header h3 {
      color: #ce93d8 !important;
    }

    .svg-instructions {
      background: rgba(156, 39, 176, 0.1);
      border: 1px solid rgba(156, 39, 176, 0.2);
      border-radius: 8px;
      padding: 12px 16px;
      margin-bottom: 16px;
      font-size: 0.85rem;
    }

    .svg-instructions strong {
      color: #ce93d8;
      display: block;
      margin-bottom: 8px;
    }

    .svg-instructions ol {
      margin: 0;
      padding-left: 20px;
      color: #aaa;
    }

    .svg-instructions li {
      margin-bottom: 4px;
    }

    .svg-instructions code {
      background: rgba(0, 0, 0, 0.3);
      padding: 2px 6px;
      border-radius: 4px;
      color: #ce93d8;
      font-size: 0.8rem;
    }

    #svgMomentumInput {
      width: 100%;
      padding: 12px;
      border-radius: 8px;
      border: 2px solid rgba(156, 39, 176, 0.3);
      background: rgba(0, 0, 0, 0.3);
      color: #fff;
      font-family: 'Monaco', 'Consolas', monospace;
      font-size: 0.85rem;
      resize: vertical;
      min-height: 120px;
      margin-bottom: 12px;
    }

    #svgMomentumInput:focus {
      outline: none;
      border-color: #9c27b0;
      box-shadow: 0 0 0 3px rgba(156, 39, 176, 0.2);
    }

    #svgMomentumInput::placeholder {
      color: #666;
    }

    .svg-preview {
      background: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
      padding: 12px;
      margin-top: 12px;
      font-size: 0.85rem;
      max-height: 150px;
      overflow-y: auto;
    }

    .svg-preview:empty {
      display: none;
    }

    .svg-preview .preview-header {
      color: #ce93d8;
      font-weight: 600;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .svg-preview .preview-stats {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
    }

    .svg-preview .preview-stat {
      background: rgba(156, 39, 176, 0.1);
      padding: 8px;
      border-radius: 6px;
      text-align: center;
    }

    .svg-preview .preview-stat-value {
      font-size: 1.2rem;
      font-weight: 600;
      color: #ce93d8;
    }

    .svg-preview .preview-stat-label {
      font-size: 0.7rem;
      color: #888;
      text-transform: uppercase;
    }

    .svg-modal-footer .svg-submit-btn {
      background: linear-gradient(135deg, #9c27b0 0%, #7b1fa2 100%) !important;
    }

    .svg-modal-footer .svg-submit-btn:hover:not(:disabled) {
      box-shadow: 0 4px 15px rgba(156, 39, 176, 0.4) !important;
    }

    .svg-momentum-btn {
      background: rgba(156, 39, 176, 0.3);
      border: 1px solid rgba(156, 39, 176, 0.5);
      color: #ce93d8;
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.75rem;
      transition: all 0.15s ease;
      margin-left: 8px;
    }

    .svg-momentum-btn:hover {
      background: rgba(156, 39, 176, 0.5);
      color: #fff;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1><svg class="icon icon-lg" style="color: var(--color-primary)"><use href="#icon-tennis"/></svg> Tennis Scraper Local</h1>
      <p>Scraping da IP locale per bypassare i blocchi dei server cloud</p>
      <span id="serverStatus" class="status-badge offline">Checking...</span>
    </header>
    
    <div class="card">
      <h2><svg class="icon"><use href="#icon-download"/></svg> Acquisisci / Aggiorna Match</h2>
      <p style="color: #888; font-size: 0.85rem; margin-bottom: 12px;">
        Incolla qualsiasi link SofaScore - i dati verranno sempre scaricati e aggiornati
      </p>
      <div class="form-group">
        <input type="text" id="urlInput" placeholder="Incolla link SofaScore (es: sofascore.com/event/12345)" />
        <button id="scrapeBtn" onclick="scrapeMatch()"><svg class="icon icon-sm"><use href="#icon-refresh"/></svg> Scrape</button>
      </div>
      <div id="alertSuccess" class="alert success"></div>
      <div id="alertError" class="alert error"></div>
      <div id="alertInfo" class="alert info"></div>
    </div>
    
    <!-- Stats Summary - Monitoraggio Scrape -->
    <div class="card stats-summary-card">
      <!-- Riga 1: Contatori principali -->
      <div class="stats-summary stats-row-main">
        <div class="stat-box">
          <svg class="icon stat-icon" style="color: var(--color-success)"><use href="#icon-check"/></svg>
          <span class="stat-number" id="loadedMatchesCount">0</span>
          <span class="stat-label">Con Link Sofa</span>
        </div>
        <div class="stat-box">
          <svg class="icon stat-icon" style="color: var(--color-warning)"><use href="#icon-download"/></svg>
          <span class="stat-number" id="noLinkCount">0</span>
          <span class="stat-label">Senza Link</span>
        </div>
        <div class="stat-box stat-box-highlight">
          <svg class="icon stat-icon" style="color: var(--color-danger)"><use href="#icon-warning"/></svg>
          <span class="stat-number" id="problematicCount">0</span>
          <span class="stat-label">Problematiche</span>
        </div>
      </div>
      
      <!-- Riga 2: Breakdown Completezza -->
      <div class="stats-summary stats-row-completeness">
        <div class="completeness-tier" data-tier="100">
          <span class="tier-value" id="tier100">0</span>
          <span class="tier-label">100%</span>
        </div>
        <div class="completeness-tier" data-tier="90">
          <span class="tier-value" id="tier90">0</span>
          <span class="tier-label">90%+</span>
        </div>
        <div class="completeness-tier" data-tier="80">
          <span class="tier-value" id="tier80">0</span>
          <span class="tier-label">80%+</span>
        </div>
        <div class="completeness-tier" data-tier="50">
          <span class="tier-value" id="tier50">0</span>
          <span class="tier-label">50%+</span>
        </div>
        <div class="completeness-tier" data-tier="under50">
          <span class="tier-value" id="tierUnder50">0</span>
          <span class="tier-label">&lt;50%</span>
        </div>
      </div>
    </div>
    
    <!-- Sezione unificata con 3 tab: Mancanti, Da completare, Problematiche -->
    <div id="matchesCard" class="card matches-card-container">
      <div class="tab-header">
        <h2 id="cardTitle"><svg class="icon"><use href="#icon-list"/></svg> Match</h2>
        <div class="tab-buttons">
          <button class="tab-btn" data-tab="missing" onclick="switchTab('missing')">
            <svg class="icon icon-sm"><use href="#icon-warning"/></svg> Mancanti <span id="missingCountBadge" class="badge" style="display: none;">0</span>
          </button>
          <button class="tab-btn active" data-tab="recent" onclick="switchTab('recent')">
            <svg class="icon icon-sm"><use href="#icon-clock"/></svg> Da completare <span class="badge" id="recentCountBadge">0</span>
          </button>
          <button class="tab-btn" data-tab="problematic" onclick="switchTab('problematic')">
            <svg class="icon icon-sm"><use href="#icon-warning"/></svg> Problematiche <span id="problematicCountBadge" class="badge badge-red" style="display: none;">0</span>
          </button>
        </div>
      </div>
      
      <!-- Tab Partite Mancanti -->
      <div id="missingTab" class="tab-content">
        <p id="tournamentInfo" class="tournament-info"></p>
        <p id="missingSourceInfo" class="source-info" style="font-size: 0.75rem; color: #888; margin-bottom: 8px;"></p>
        <div id="missingList" class="missing-list"></div>
      </div>
      
      <!-- Tab Partite Recenti -->
      <div id="recentTab" class="tab-content active">
        <div id="matchesList" class="matches-list">
          <!-- Skeleton loading -->
          <div class="skeleton-card"><div class="skeleton skeleton-line long"></div><div class="skeleton skeleton-line medium"></div></div>
          <div class="skeleton-card"><div class="skeleton skeleton-line long"></div><div class="skeleton skeleton-line short"></div></div>
          <div class="skeleton-card"><div class="skeleton skeleton-line medium"></div><div class="skeleton skeleton-line short"></div></div>
        </div>
      </div>
      
      <!-- Tab Partite Problematiche -->
      <div id="problematicTab" class="tab-content">
        <p class="problematic-info-text">Partite ended 3+ giorni fa non ancora al 100%. Dopo 3 refresh verranno marcate come non completabili.</p>
        <div id="problematicList" class="problematic-list"></div>
      </div>
    </div>
  </div>
  
  <!-- Modal per inserimento link -->
  <div id="linkModal" class="modal" style="display: none;">
    <div class="modal-content">
      <div class="modal-header">
        <h3>Collega Partita</h3>
        <span class="modal-close" onclick="closeModal()">&times;</span>
      </div>
      <div class="modal-body">
        <p id="modalMatchInfo"></p>
        <input type="text" id="modalLinkInput" placeholder="Incolla link SofaScore del match" />
        <div id="modalValidation" class="modal-validation"></div>
      </div>
      <div class="modal-footer">
        <button onclick="closeModal()" class="btn-cancel">Annulla</button>
        <button onclick="submitModalLink()" id="modalSubmitBtn" disabled>Acquisisci</button>
      </div>
    </div>
  </div>
  
  <!-- Modal per inserimento SVG Momentum -->
  <div id="svgMomentumModal" class="modal svg-momentum-modal" style="display: none;">
    <div class="modal-content svg-modal-content">
      <div class="modal-header svg-modal-header">
        <h3>ðŸ“Š Inserisci SVG Momentum</h3>
        <span class="modal-close" onclick="closeSvgMomentumModal()">&times;</span>
      </div>
      <div class="modal-body svg-modal-body">
        <p id="svgModalMatchInfo"></p>
        <div class="svg-instructions">
          <strong>Istruzioni:</strong>
          <ol>
            <li>Vai su SofaScore alla pagina del match</li>
            <li>Apri DevTools (F12) â†’ Elements</li>
            <li>Trova il div con classe <code>momentum-graph</code></li>
            <li>Copia l'HTML completo (tutti i &lt;path&gt; con le classi fill)</li>
            <li>Incolla qui sotto</li>
          </ol>
        </div>
        <textarea id="svgMomentumInput" placeholder="Incolla qui l'HTML SVG del momentum graph..." rows="8"></textarea>
        <div id="svgMomentumValidation" class="modal-validation"></div>
        <div id="svgMomentumPreview" class="svg-preview"></div>
      </div>
      <div class="modal-footer svg-modal-footer">
        <button onclick="closeSvgMomentumModal()" class="btn-cancel">Annulla</button>
        <button onclick="submitSvgMomentum()" id="svgMomentumSubmitBtn" disabled class="svg-submit-btn">
          Salva Momentum
        </button>
      </div>
    </div>
  </div>
  
  <script>
    const API_BASE = '/api';
    const MATCHES_PER_PAGE = 20;
    let currentPage = 1;
    let currentMissingPage = 1;
    let totalMatches = 0;
    let allMatchesFromDb = []; // Tutti i match dal DB prima del filtro
    let allMatches = [];        // Match visibili in lista (dopo filtro)
    let missingMatches = [];    // Partite da acquisire
    let selectedMissingMatch = null;
    
    // Flags per evitare skeleton su ogni refresh
    let isFirstMatchLoad = true;
    let isFirstMissingLoad = true;
    let isUpdating = false;
    let missingMatchesLoaded = false; // Lazy load - carica solo su click tab
    
    // Stats avanzate dal DB (detected_matches)
    let advancedStats = {
      totalInDb: 0,           // Partite nel DB matches
      acquiredLast24h: 0,     // Acquisite ultime 24h
      totalDetected: 0,       // Totale rilevate
      totalAcquired: 0,       // GiÃ  acquisite
      totalMissing: 0,        // Da acquisire
      acquisitionRate: 0,     // Percentuale acquisizione
      tournaments: []         // Breakdown per torneo
    };
    
    // Valori precedenti per rilevare cambiamenti
    let prevStats = {
      loaded: null,
      missing: null,
      total: null,
      list: null,
      last24h: null
    };
    
    // Anima un numero con effetto roll sottile
    function animateNumber(element, newValue, duration = 250) {
      const oldValue = parseInt(element.textContent) || 0;
      if (oldValue === newValue) return;
      
      // Crea contenitore per i digit animati
      const digits = String(newValue).split('');
      const oldDigits = String(oldValue).padStart(digits.length, ' ').split('');
      
      let html = '';
      digits.forEach((digit, i) => {
        const oldDigit = oldDigits[i] || '';
        const changed = oldDigit !== digit;
        
        if (changed) {
          html += `<span class="roll-digit" style="animation-delay: ${i * 30}ms">${digit}</span>`;
        } else {
          html += `<span>${digit}</span>`;
        }
      });
      
      element.innerHTML = html;
      element.classList.add('updating');
      
      setTimeout(() => {
        element.classList.remove('updating');
      }, duration + digits.length * 30);
    }
    
    // Anima percentuale - motion sottile
    function animatePercent(element, newValue) {
      const oldText = element.textContent;
      if (oldText === newValue) return;
      
      element.style.opacity = '0.6';
      
      setTimeout(() => {
        element.textContent = newValue;
        element.style.opacity = '1';
      }, 100);
    }
    
    // Update all stats counters - focus su monitoraggio scrape
    // silent = true evita re-render pesanti (solo aggiorna numeri)
    let lastProblematicIds = [];
    
    function updateStatsDisplay(silent = false) {
      // Calcola statistiche di completezza da allMatchesFromDb
      const completenessStats = calculateCompletenessStats();
      const problematicMatches = findProblematicMatches();
      
      // Riga 1: Stats principali
      const withLinkEl = document.getElementById('loadedMatchesCount');
      const noLinkEl = document.getElementById('noLinkCount');
      const problematicEl = document.getElementById('problematicCount');
      
      // Match con link SofaScore valido = match nel DB con ID < 900 miliardi (non fake)
      const withLink = allMatchesFromDb.filter(m => m.id && m.id < 900000000000).length;
      // Match senza link = missingMatches (rilevate dallo scraping ma non ancora acquisite)
      const noLink = missingMatches.length || 0;
      // Problematiche (ended 3+ giorni, < 80% completezza, < 3 refresh)
      const problematicCount = problematicMatches.length;
      
      // Aggiorna numeri solo se cambiati
      if (parseInt(withLinkEl.textContent) !== withLink) {
        animateNumber(withLinkEl, withLink);
      }
      if (parseInt(noLinkEl.textContent) !== noLink) {
        animateNumber(noLinkEl, noLink);
      }
      if (parseInt(problematicEl.textContent) !== problematicCount) {
        animateNumber(problematicEl, problematicCount);
      }
      
      // Riga 2: Breakdown completezza (update diretto, nessuna animazione pesante)
      document.getElementById('tier100').textContent = completenessStats.tier100;
      document.getElementById('tier90').textContent = completenessStats.tier90;
      document.getElementById('tier80').textContent = completenessStats.tier80;
      document.getElementById('tier50').textContent = completenessStats.tier50;
      document.getElementById('tierUnder50').textContent = completenessStats.tierUnder50;
      
      // Badge tabs (aggiorna solo se necessario)
      const missingCountBadge = document.getElementById('missingCountBadge');
      const recentCountBadge = document.getElementById('recentCountBadge');
      const problematicCountBadge = document.getElementById('problematicCountBadge');
      
      // Badge Mancanti
      if (missingMatches.length > 0) {
        if (missingCountBadge.textContent !== String(missingMatches.length)) {
          missingCountBadge.textContent = missingMatches.length;
        }
        missingCountBadge.style.display = 'inline-block';
      } else {
        missingCountBadge.style.display = 'none';
      }
      
      // Badge Da completare
      if (recentCountBadge && recentCountBadge.textContent !== String(allMatches.length)) {
        recentCountBadge.textContent = allMatches.length;
      }
      
      // Badge Problematiche
      if (problematicCount > 0) {
        if (problematicCountBadge.textContent !== String(problematicCount)) {
          problematicCountBadge.textContent = problematicCount;
        }
        problematicCountBadge.style.display = 'inline-block';
      } else {
        problematicCountBadge.style.display = 'none';
      }
      
      // Aggiorna lista problematiche solo se il tab Ã¨ attivo e lista cambiata
      const problematicTabActive = document.getElementById('problematicTab').classList.contains('active');
      const currentProblematicIds = problematicMatches.map(m => m.id).join(',');
      
      if (problematicTabActive && (!silent || currentProblematicIds !== lastProblematicIds.join(','))) {
        lastProblematicIds = problematicMatches.map(m => m.id);
        renderProblematicMatches();
      }
    }
    
    // Render lista problematiche nel tab
    function renderProblematicMatches() {
      const problematicList = document.getElementById('problematicList');
      const problematicMatches = findProblematicMatches();
      
      if (problematicMatches.length === 0) {
        problematicList.innerHTML = '<div class="loading">âœ“ Nessuna partita problematica</div>';
        return;
      }
      
      problematicList.innerHTML = problematicMatches.map(m => {
        const homeName = getPlayerName(m.home_player);
        const awayName = getPlayerName(m.away_player);
        const tournamentName = getTournamentName(m.tournament);
        const daysOld = m._daysOld || 0;
        const refreshCount = m.refresh_count || 0;
        const sofascoreId = m.id || '';
        
        return `
          <div class="problematic-match" data-match-id="${m.id}" data-sofascore-id="${sofascoreId}">
            <div class="match-info">
              <div class="players">${homeName} vs ${awayName}</div>
              <div class="meta">${tournamentName} - ${m.completeness || 0}%</div>
            </div>
            <div class="stats">
              <span class="days-old">${daysOld}gg</span>
              <span class="refresh-count">${refreshCount}/3</span>
              <button class="svg-momentum-btn" onclick="openSvgMomentumModal('${sofascoreId}')" title="Inserisci momentum da SVG">
                ðŸ“Š SVG
              </button>
              <button class="refresh-btn" onclick="refreshProblematicMatch(this, '${sofascoreId}')" title="Refresh (al 3Â° tentativo verrÃ  marcata non completabile)">
                <svg class="icon icon-sm"><use href="#icon-refresh"/></svg>
              </button>
            </div>
          </div>
        `;
      }).join('');
    }
    
    // Calcola breakdown di completezza dai match nel DB
    function calculateCompletenessStats() {
      const stats = {
        tier100: 0,  // 100%
        tier90: 0,   // 90-99%
        tier80: 0,   // 80-89%
        tier50: 0,   // 50-79%
        tierUnder50: 0 // < 50%
      };
      
      allMatchesFromDb.forEach(m => {
        const comp = m.completeness || 0;
        if (comp >= 100) {
          stats.tier100++;
        } else if (comp >= 90) {
          stats.tier90++;
        } else if (comp >= 80) {
          stats.tier80++;
        } else if (comp >= 50) {
          stats.tier50++;
        } else {
          stats.tierUnder50++;
        }
      });
      
      return stats;
    }
    
    // Trova partite problematiche: ended 3+ giorni fa, < 100%, link SofaScore valido, meno di 3 refresh
    function findProblematicMatches() {
      const now = Date.now();
      
      return allMatchesFromDb.filter(m => {
        // DEVE avere link SofaScore valido (ID < 900 miliardi)
        if (!m.id || m.id > 900000000000) return false;
        
        // Escludi match giÃ  marcati come force_completed
        if (m.force_completed) return false;
        
        const statusDesc = (m.status_description || '').toLowerCase();
        const isEnded = statusDesc === 'ended' || statusDesc.includes('finished');
        const completeness = m.completeness || 0;
        const refreshCount = m.refresh_count || 0;
        const matchDate = new Date(m.start_time || m.extracted_at);
        const daysDiff = (now - matchDate.getTime()) / (1000 * 60 * 60 * 24);
        
        // Criterio: ended, 3+ giorni fa, non ancora 100%, meno di 3 refresh
        // Dopo 3 refresh viene considerata "non completabile" e non appare piÃ¹
        if (isEnded && daysDiff >= 3 && completeness < 100 && refreshCount < 3) {
          m._daysOld = Math.floor(daysDiff);
          return true;
        }
        return false;
      }).slice(0, 50); // Mostra max 50
    }
    
    // Refresh partita problematica - al 3Â° tentativo viene marcata completa
    async function refreshProblematicMatch(btn, sofascoreId) {
      if (!sofascoreId || btn.classList.contains('loading')) return;
      
      btn.classList.add('loading');
      btn.textContent = '...';
      
      try {
        // Usa endpoint leggero - SOLO incrementa contatore, NO scraping
        const res = await fetch(`${API_BASE}/increment-refresh/${sofascoreId}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' }
        });
        
        const data = await res.json();
        
        if (res.ok) {
          console.log(`ðŸ”„ Match ${sofascoreId} refresh: ${data.refreshCount}/3${data.forceCompleted ? ' (force completed!)' : ''}`);
          
          // Aggiorna subito il contatore visivo nella UI
          const matchEl = document.querySelector(`[data-sofascore-id="${sofascoreId}"]`);
          if (matchEl) {
            const countEl = matchEl.querySelector('.refresh-count');
            if (countEl) countEl.textContent = `${data.refreshCount}/3`;
          }
          
          // Se force completed, rimuovi dalla lista
          if (data.forceCompleted) {
            if (matchEl) matchEl.remove();
          }
          
          // Ricarica match dal DB per sync
          await loadMatches(true);
          updateStatsDisplay(true);
        } else {
          console.error('Refresh failed:', data.message || data.error);
        }
      } catch (e) {
        console.error('Error refreshing problematic match:', e);
      } finally {
        btn.classList.remove('loading');
        btn.innerHTML = '<svg class="icon icon-sm"><use href="#icon-refresh"/></svg>';
      }
    }
    
    // Check server status
    async function checkServerStatus() {
      const badge = document.getElementById('serverStatus');
      try {
        const res = await fetch(`${API_BASE}/health`);
        if (res.ok) {
          badge.textContent = 'Online';
          badge.className = 'status-badge online';
          return true;
        }
      } catch (e) {}
      badge.textContent = 'Offline';
      badge.className = 'status-badge offline';
      return false;
    }
    
    // Load stats from DB
    // Acquisiti = match nel DB (abbiamo il link)
    // Mancanti = calcolato da loadMissingMatches()
    async function loadAdvancedStats() {
      try {
        const res = await fetch(`${API_BASE}/stats`);
        const data = await res.json();
        advancedStats.totalInDb = data.totalMatches || 0;       // Match acquisiti (hanno link)
        advancedStats.acquiredLast24h = data.matchesLast24h || 0;
        console.log(`ðŸ“Š Stats DB: ${advancedStats.totalInDb} match acquisiti, ${advancedStats.acquiredLast24h} ultime 24h`);
      } catch (e) {
        console.error('Error loading stats:', e);
      }
      
      updateStatsDisplay();
    }
    
    // Format date
    function formatDate(dateStr) {
      if (!dateStr) return 'N/A';
      const date = new Date(dateStr);
      if (isNaN(date.getTime())) return 'N/A';
      return date.toLocaleDateString('it-IT', { 
        day: '2-digit', 
        month: 'short',
        hour: '2-digit',
        minute: '2-digit'
      });
    }
    
    // Switch tab - 3 tab: missing, recent, problematic
    function switchTab(tabName) {
      // Hide all tabs
      document.getElementById('missingTab').classList.remove('active');
      document.getElementById('recentTab').classList.remove('active');
      document.getElementById('problematicTab').classList.remove('active');
      
      // Remove active from all buttons
      document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
      
      // Show selected tab
      if (tabName === 'missing') {
        document.getElementById('missingTab').classList.add('active');
        document.querySelector('[data-tab="missing"]').classList.add('active');
        // Carica mancanti solo quando apri il tab (lazy load)
        if (!missingMatchesLoaded) {
          loadMissingMatches();
        }
      } else if (tabName === 'recent') {
        document.getElementById('recentTab').classList.add('active');
        document.querySelector('[data-tab="recent"]').classList.add('active');
      } else if (tabName === 'problematic') {
        document.getElementById('problematicTab').classList.add('active');
        document.querySelector('[data-tab="problematic"]').classList.add('active');
        // Aggiorna lista problematiche quando si apre il tab
        renderProblematicMatches();
      }
    }
    
    // Get player name safely
    function getPlayerName(player) {
      if (!player) return 'Unknown';
      if (typeof player === 'string') return player;
      return player.name || player.short_name || 'Unknown';
    }
    
    // Get tournament name safely
    function getTournamentName(tournament) {
      if (!tournament) return 'N/A';
      if (typeof tournament === 'string') return tournament;
      return tournament.name || 'N/A';
    }
    
    // Render match item - with action buttons
    function renderMatch(m, index) {
      const homeName = getPlayerName(m.home_player);
      const awayName = getPlayerName(m.away_player);
      const tournamentName = getTournamentName(m.tournament);
      const dateStr = formatDate(m.extracted_at || m.start_time);
      const score = m.home_sets_won !== null && m.away_sets_won !== null 
        ? `${m.home_sets_won} - ${m.away_sets_won}` 
        : '';
      // Determina classe CSS per lo status
      const statusDesc = (m.status_description || '').toLowerCase();
      let statusClass = 'finished'; // default
      if (m.is_live) {
        statusClass = 'live';
      } else if (statusDesc.includes('not started')) {
        statusClass = 'notstarted';
      } else if (statusDesc.includes('ended')) {
        statusClass = 'ended';
      } else if (statusDesc.includes('retired')) {
        statusClass = 'retired';
      } else if (statusDesc.includes('walkover')) {
        statusClass = 'walkover';
      } else if (statusDesc.includes('cancelled') || statusDesc.includes('postponed')) {
        statusClass = 'cancelled';
      } else if (statusDesc.includes('interrupted')) {
        statusClass = 'interrupted';
      }
      const statusText = m.is_live ? 'LIVE' : (m.status_description || '');
      // In Supabase, match.id IS the sofascore event ID
      const sofascoreId = m.id || '';
      
      // Percentuale completamento
      const completeness = m.completeness || 0;
      const isComplete = completeness >= 100;
      const completenessColor = completeness >= 100 ? '#4caf50' : completeness >= 70 ? '#ff9800' : '#f44336';
      
      return `
        <div class="match-item ${isComplete ? 'complete' : ''}" 
             data-match-id="${m.id}" 
             data-sofascore-id="${sofascoreId}">
          <div class="match-left">
            <div class="match-players">
              ${homeName} vs ${awayName}
              ${score ? `<span class="match-score">${score}</span>` : ''}
            </div>
            <div class="match-tournament">
              ${tournamentName}
              ${m.round_name ? ` Â· ${m.round_name}` : ''}
            </div>
            <div class="completeness-bar">
              <div class="completeness-bar-fill" style="width: ${completeness}%; background: ${completenessColor}"></div>
            </div>
          </div>
          <div class="match-right">
            <div class="match-date">${dateStr}</div>
            ${statusText ? `<span class="match-status ${statusClass}">${statusText}</span>` : ''}
            <span class="completeness-badge" style="background: ${completenessColor}">${completeness}%</span>
            <div class="match-actions">
              <button class="match-action-btn refresh-api-btn" onclick="event.stopPropagation(); refreshSingleMatch(this.closest('.match-item'), '${sofascoreId}')" title="Aggiorna via API">
                <svg class="icon icon-sm"><use href="#icon-refresh"/></svg>
              </button>
              <button class="match-action-btn svg-momentum-btn" onclick="event.stopPropagation(); openSvgMomentumModal('${sofascoreId}')" title="Inserisci Momentum SVG">
                ðŸ“Š
              </button>
            </div>
          </div>
        </div>
      `;
    }
    
    // Refresh single match on click - fa SEMPRE scrape completo e aggiorna
    async function refreshSingleMatch(element, sofascoreId) {
      if (!sofascoreId) {
        console.warn('No sofascore_id for this match');
        return;
      }
      
      // Already syncing
      if (element.classList.contains('syncing')) return;
      
      // Add syncing state and loader
      element.classList.add('syncing');
      const loaderHtml = `
        <div class="match-loader">
          <div class="mini-spinner"></div>
          <span>Scraping completo...</span>
        </div>
      `;
      element.insertAdjacentHTML('beforeend', loaderHtml);
      
      try {
        const url = `https://www.sofascore.com/event/${sofascoreId}`;
        const res = await fetch(`${API_BASE}/scrape`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ url })
        });
        
        const data = await res.json();
        
        if (res.ok) {
          console.log(`âœ… Match ${sofascoreId} ${data.isUpdate ? 'aggiornato' : 'acquisito'}`);
          
          // Ricarica tutto in modo silenzioso (no skeleton)
          await loadAdvancedStats();
          await loadMatches(true);
          await loadMissingMatches(true);
        } else {
          console.error('Refresh failed:', data.message || data.error);
        }
      } catch (e) {
        console.error('Error refreshing match:', e);
      } finally {
        // Remove syncing state
        element.classList.remove('syncing');
        const loader = element.querySelector('.match-loader');
        if (loader) loader.remove();
      }
    }
    
    // Genera skeleton cards
    function renderSkeletonCards(count = 3) {
      return Array(count).fill(0).map(() => `
        <div class="skeleton-card">
          <div class="skeleton skeleton-line long"></div>
          <div class="skeleton skeleton-line medium"></div>
        </div>
      `).join('');
    }

    // Load recent matches with pagination and completeness
    async function loadMatches(silent = false) {
      const container = document.getElementById('matchesList');
      
      // Skeleton solo al primo caricamento
      if (isFirstMatchLoad && !silent) {
        container.innerHTML = renderSkeletonCards(4);
      } else if (!silent) {
        // Sui refresh successivi, aggiungi classe updating per feedback visivo sottile
        container.classList.add('updating');
      }
      
      try {
        const res = await fetch(`${API_BASE}/matches?limit=200&completeness=true`);
        let fetchedMatches = await res.json();
        
        // Salva tutti i match dal DB (prima del filtro)
        allMatchesFromDb = fetchedMatches;
        
        // Filtra partite per la visualizzazione:
        // - Se completezza >= 100% â†’ nascondi (giÃ  complete)
        // - Se status = "Retired", "Walkover", "Cancelled", etc. â†’ nascondi (non acquisibili)
        // - Se "Ended" + vecchia di 3+ giorni + completeness < 50% â†’ nascondi (dati non piÃ¹ ottenibili)
        // - Se ID > 900000000000 â†’ nascondi (ID fake/invalidi)
        // - Se players = "Unknown" â†’ nascondi (dati incompleti)
        // - Tutto il resto rimane visibile
        allMatches = fetchedMatches.filter(m => {
          const completeness = m.completeness || 0;
          const statusDesc = (m.status_description || '').toLowerCase();
          const homeName = getPlayerName(m.home_player);
          const awayName = getPlayerName(m.away_player);
          const tournamentName = getTournamentName(m.tournament);
          
          // Filtro ID fake (> 900 miliardi)
          if (m.id && m.id > 900000000000) return false;
          
          // Filtro Unknown players o N/A tournament
          if (homeName === 'Unknown' || awayName === 'Unknown') return false;
          if (tournamentName === 'N/A') return false;
          
          // Status non acquisibili (partite senza dati utili)
          const nonAcquisibili = ['retired', 'walkover', 'cancelled', 'canceled', 'postponed', 'abandoned'];
          const isNonAcquisibile = nonAcquisibili.some(s => statusDesc.includes(s));
          
          // Se completa al 100%, nascondi
          if (completeness >= 100) return false;
          // Se non acquisibile (retired, walkover, etc.), nascondi
          if (isNonAcquisibile) return false;
          
          // Se "Ended" e vecchia di 3+ giorni con pochi dati, considera finita
          if (statusDesc === 'ended' && completeness < 50) {
            const matchDate = new Date(m.start_time || m.extracted_at);
            const daysDiff = (Date.now() - matchDate.getTime()) / (1000 * 60 * 60 * 24);
            if (daysDiff > 3) {
              console.log(`â° Match ${m.id} nascosto: Ended + vecchio ${daysDiff.toFixed(1)} giorni + ${completeness}% completeness`);
              return false;
            }
          }
          
          return true;
        });
        
        console.log('Match dal DB:', allMatchesFromDb.length, '| Visibili in lista:', allMatches.length);
        
        // Aggiorna contatori (silent mode se non Ã¨ primo caricamento)
        updateStatsDisplay(silent);
        
        if (!allMatches.length) {
          if (!silent) {
            container.innerHTML = '<div class="loading">âœ“ Nessun match da completare</div>';
          }
        } else {
          renderMatchesPage();
        }
        
        // Primo caricamento completato
        isFirstMatchLoad = false;
      } catch (e) {
        console.error('Error loading matches:', e);
        if (isFirstMatchLoad) {
          container.innerHTML = '<div class="loading" style="color:#ef9a9a">âš  Errore caricamento</div>';
        }
      } finally {
        container.classList.remove('updating');
      }
    }
    
    // SCAN TORNEI - Fa chiamate API per aggiornare detected_matches
    // FILOSOFIA: Le chiamate API vanno fatte SOLO quando l'utente lo richiede esplicitamente
    async function scanAllTournaments() {
      const btn = document.getElementById('scanTournamentsBtn');
      const sourceInfo = document.getElementById('missingSourceInfo');
      const originalText = btn.innerHTML;
      
      btn.disabled = true;
      btn.innerHTML = 'â³ Scanning...';
      sourceInfo.textContent = 'ðŸ”„ Scansione tornei in corso (chiamate API a SofaScore)...';
      
      try {
        const res = await fetch(`${API_BASE}/scan-all-tournaments`, { method: 'POST' });
        const data = await res.json();
        
        if (data.success) {
          sourceInfo.textContent = `âœ… Scan completato: ${data.tournamentsScanned} tornei, ${data.totalEventsDetected} eventi rilevati`;
          // Ricarica le mancanti dal DB aggiornato
          missingMatchesLoaded = false;
          await loadMissingMatches();
        } else {
          sourceInfo.textContent = 'âŒ Errore durante lo scan';
        }
      } catch (e) {
        console.error('Error scanning tournaments:', e);
        sourceInfo.textContent = 'âŒ Errore: ' + e.message;
      } finally {
        btn.disabled = false;
        btn.innerHTML = originalText;
      }
    }
    
    // Load missing matches - partite rilevate dai tornei ma NON nel nostro DB
    // FILOSOFIA DB: Legge SOLO da database (detected_matches), zero chiamate API
    async function loadMissingMatches(silent = false) {
      const missingList = document.getElementById('missingList');
      const tournamentInfo = document.getElementById('tournamentInfo');
      const missingCountBadge = document.getElementById('missingCountBadge');
      
      // Skeleton solo al primo caricamento
      if (isFirstMissingLoad && !silent) {
        missingList.innerHTML = renderSkeletonCards(3);
      } else if (!silent) {
        missingList.classList.add('updating');
      }
      
      try {
        // FILOSOFIA DB: Legge SOLO da database, zero chiamate API
        const res = await fetch(`${API_BASE}/missing-matches`);
        const data = await res.json();
        
        // Mostra la source dei dati
        const sourceInfo = document.getElementById('missingSourceInfo');
        if (data.source === 'database') {
          sourceInfo.textContent = 'ðŸ“Š Dati da database (zero chiamate API)';
        } else {
          sourceInfo.textContent = '';
        }
        
        if (data.message && data.missingMatches?.length === 0) {
          // Tabella vuota, suggerisci scan
          sourceInfo.textContent = 'âš ï¸ ' + data.message;
        }
        
        if (!data.missingMatches || data.missingMatches.length === 0) {
          missingMatches = [];
          if (!silent) {
            missingList.innerHTML = '<div class="loading">âœ“ Tutte le partite acquisite (o dati da aggiornare)</div>';
          }
          missingCountBadge.style.display = 'none';
          tournamentInfo.textContent = '';
        } else {
          missingMatches = data.missingMatches;
          
          // Filtra quelle non acquisibili (Retired, Walkover, Cancelled, etc.)
          missingMatches = missingMatches.filter(m => {
            const statusDesc = (m.status?.description || '').toLowerCase();
            const nonAcquisibili = ['retired', 'walkover', 'cancelled', 'canceled', 'postponed', 'abandoned'];
            return !nonAcquisibili.some(s => statusDesc.includes(s));
          });
          
          console.log(`ðŸ“‹ Partite mancanti da DB: ${missingMatches.length}`);
          
          if (missingMatches.length === 0) {
            if (!silent) {
              missingList.innerHTML = '<div class="loading">âœ“ Tutte le partite acquisite</div>';
            }
            missingCountBadge.style.display = 'none';
            tournamentInfo.textContent = '';
          } else {
            // Raggruppa per torneo
            const tournamentNames = [...new Set(missingMatches.map(m => m.tournamentName).filter(Boolean))];
            tournamentInfo.textContent = `${tournamentNames.length} tornei - ${missingMatches.length} partite da acquisire`;
            
            missingCountBadge.textContent = missingMatches.length;
            missingCountBadge.style.display = 'inline-block';
            
            renderMissingMatches();
          }
        }
        
        // Aggiorna stats (senza re-render problematiche se silent)
        updateStatsDisplay(silent);
        
        // Caricamento completato
        isFirstMissingLoad = false;
        missingMatchesLoaded = true;
      } catch (e) {
        console.error('Error loading missing matches:', e);
        if (isFirstMissingLoad) {
          missingList.innerHTML = '<div class="loading" style="color:#ef9a9a">âš  Errore caricamento</div>';
        }
      } finally {
        missingList.classList.remove('updating');
      }
    }
    
    // Render current page of matches con fade-in sottile
    function renderMatchesPage() {
      const container = document.getElementById('matchesList');
      const totalPages = Math.ceil(allMatches.length / MATCHES_PER_PAGE);
      const start = (currentPage - 1) * MATCHES_PER_PAGE;
      const end = start + MATCHES_PER_PAGE;
      const pageMatches = allMatches.slice(start, end);
      
      let html = pageMatches.map(renderMatch).join('');
      
      // Add pagination if needed
      if (allMatches.length > MATCHES_PER_PAGE) {
        html += `
          <div class="pagination">
            <button onclick="changePage(-1)" ${currentPage === 1 ? 'disabled' : ''}>
              â† Precedente
            </button>
            <span class="page-info">
              Pagina ${currentPage} di ${totalPages} (${allMatches.length} match)
            </span>
            <button onclick="changePage(1)" ${currentPage === totalPages ? 'disabled' : ''}>
              Successiva â†’
            </button>
          </div>
        `;
      }
      
      // Applica contenuto - nessun flash visivo
      container.innerHTML = html;
    }
    
    // Change page
    function changePage(delta) {
      const totalPages = Math.ceil(allMatches.length / MATCHES_PER_PAGE);
      const newPage = currentPage + delta;
      if (newPage >= 1 && newPage <= totalPages) {
        currentPage = newPage;
        renderMatchesPage();
      }
    }
    
    // Scrape match - SEMPRE fa scrape completo e aggiorna
    async function scrapeMatch() {
      const url = document.getElementById('urlInput').value.trim();
      const btn = document.getElementById('scrapeBtn');
      const alertSuccess = document.getElementById('alertSuccess');
      const alertError = document.getElementById('alertError');
      const alertInfo = document.getElementById('alertInfo');
      
      // Hide all alerts
      alertSuccess.className = 'alert success';
      alertError.className = 'alert error';
      alertInfo.className = 'alert info';
      
      if (!url) {
        alertError.textContent = 'Inserisci un URL SofaScore';
        alertError.className = 'alert error show';
        return;
      }
      
      btn.disabled = true;
      btn.innerHTML = '<span class="btn-loader"></span> Scraping...';
      
      try {
        const res = await fetch(`${API_BASE}/scrape`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ url })
        });
        
        const data = await res.json();
        
        if (!res.ok) {
          // Error
          alertError.textContent = data.message || data.error || 'Errore sconosciuto';
          alertError.className = 'alert error show';
        } else {
          // Success - mostra messaggio appropriato (nuovo o aggiornato)
          const msg = data.message || `${data.isUpdate ? 'Aggiornato' : 'Acquisito'}: ${data.match?.homeTeam} vs ${data.match?.awayTeam}`;
          
          if (data.isUpdate) {
            // Era un aggiornamento
            alertInfo.textContent = msg;
            alertInfo.className = 'alert info show';
          } else {
            // Nuovo match
            alertSuccess.textContent = msg;
            alertSuccess.className = 'alert success show';
          }
          
          document.getElementById('urlInput').value = '';
          
          // Aggiorna stats e matches (silent)
          currentPage = 1;
          await loadAdvancedStats();
          await loadMatches(true);
          
          // Ricarica lista partite mancanti (silent)
          await loadMissingMatches(true);
        }
      } catch (e) {
        alertError.textContent = `Errore di connessione: ${e.message}`;
        alertError.className = 'alert error show';
      } finally {
        btn.disabled = false;
        btn.textContent = 'Scrape';
      }
    }
    
    // Detect missing matches from a tournament and save to detected_matches DB
    async function detectMissingFromTournament(tournamentId, tournamentName) {
      const missingList = document.getElementById('missingList');
      const tournamentInfo = document.getElementById('tournamentInfo');
      const missingCountBadge = document.getElementById('missingCountBadge');
      
      try {
        console.log('Scansione torneo e salvataggio in DB:', tournamentId);
        
        // Usa il nuovo endpoint che scansiona E salva in detected_matches
        const scanRes = await fetch(`${API_BASE}/scan-tournament/${tournamentId}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ tournamentName })
        });
        
        if (scanRes.ok) {
          const scanData = await scanRes.json();
          console.log('Scansione completata:', scanData);
          
          // Ricarica stats e partite mancanti dal DB (silent)
          await loadAdvancedStats();
          await loadMissingMatches(true);
          await loadMatches(true);
          
          // Auto-switch to missing tab se ci sono partite mancanti
          if (advancedStats.totalMissing > 0) {
            switchTab('missing');
          }
          
          return;
        }
        
        // Fallback: vecchio sistema se scan fallisce
        console.log('Fallback al vecchio sistema di rilevamento');
        
        // Fetch tournament events direttamente
        const eventsRes = await fetch(`${API_BASE}/tournament-events/${tournamentId}`);
        if (!eventsRes.ok) {
          console.error('Errore recupero eventi torneo');
          return;
        }
        
        const eventsData = await eventsRes.json();
        const tournamentEvents = eventsData.events || [];
        
        if (tournamentEvents.length === 0) {
          return;
        }
        
        // Reload matches to get fresh data (silent)
        await loadMatches(true);
        
        // Get existing match IDs from our database
        const existingIds = new Set(allMatchesFromDb.map(m => m.id));
        
        // Filter missing matches
        missingMatches = tournamentEvents.filter(e => !existingIds.has(e.id));
        
        // Filtra quelle giÃ  finite con risultato E quelle non acquisibili (Retired, Walkover, etc.)
        missingMatches = missingMatches.filter(m => {
          const statusDesc = (m.status?.description || '').toLowerCase();
          const statusType = m.status?.type || '';
          
          // Escludi Retired, Walkover, Cancelled, Postponed, Abandoned (non acquisibili)
          const nonAcquisibili = ['retired', 'walkover', 'cancelled', 'canceled', 'postponed', 'abandoned'];
          if (nonAcquisibili.some(s => statusDesc.includes(s))) return false;
          
          // Escludi quelle giÃ  finite con risultato
          const isEnded = statusDesc === 'ended' || statusType === 'finished';
          const hasScore = m.homeScore?.current !== undefined && m.awayScore?.current !== undefined;
          if (isEnded && hasScore) return false;
          
          return true;
        });
        
        if (missingMatches.length === 0) {
          console.log('Tutte le partite del torneo sono giÃ  nel DB');
          missingList.innerHTML = '<div class="loading">Tutte le partite del torneo sono giÃ  acquisite!</div>';
          missingCountBadge.style.display = 'none';
          updateStatsDisplay();
          return;
        }
        
        // Show missing matches
        tournamentInfo.textContent = `Torneo: ${tournamentName || 'Sconosciuto'} - ${tournamentEvents.length} totali, ${missingMatches.length} da acquisire`;
        missingCountBadge.textContent = missingMatches.length;
        missingCountBadge.style.display = 'inline-block';
        
        updateStatsDisplay();
        renderMissingMatches();
        switchTab('missing');
        
      } catch (e) {
        console.error('Errore rilevamento partite mancanti:', e);
      }
    }
    
    // Render missing matches in yellow cards (fallback per vecchio formato SofaScore)
    function renderMissingMatches() {
      const list = document.getElementById('missingList');
      const badge = document.getElementById('missingCountBadge');
      
      if (missingMatches.length === 0) {
        list.innerHTML = '<div class="loading">Nessuna partita mancante</div>';
        badge.style.display = 'none';
        return;
      }
      
      badge.textContent = missingMatches.length;
      badge.style.display = 'inline-block';
      
      // Paginazione
      const totalPages = Math.ceil(missingMatches.length / MATCHES_PER_PAGE);
      const start = (currentMissingPage - 1) * MATCHES_PER_PAGE;
      const end = start + MATCHES_PER_PAGE;
      const pageMatches = missingMatches.slice(start, end);
      
      let html = pageMatches.map((m, idx) => {
        const realIndex = start + idx; // Indice reale nell'array completo
        const matchId = m.id || m.sofascoreId; // ID della partita per rimozione
        const homeName = m.homeTeam?.name || m.homeTeam?.shortName || 'TBD';
        const awayName = m.awayTeam?.name || m.awayTeam?.shortName || 'TBD';
        const statusText = m.status?.description || 'Da acquisire';
        const roundName = m.roundInfo?.name || '';
        const tournamentName = m.tournamentName || m.tournament?.uniqueTournament?.name || '';
        const startTime = m.startTimestamp ? formatDate(new Date(m.startTimestamp * 1000).toISOString()) : '';
        
        return `
          <div class="missing-match-card" data-match-id="${matchId}" onclick="openMissingModal(${realIndex})" title="Clicca per copiare i nomi">
            <div class="card-left">
              <div class="players">${homeName} vs ${awayName}</div>
              <div class="round-info">${tournamentName}${roundName ? ' â€¢ ' + roundName : ''}</div>
            </div>
            <div class="card-right">
              <span class="status-badge">${statusText}</span>
              ${startTime ? `<div class="date-info">${startTime}</div>` : ''}
            </div>
          </div>
        `;
      }).join('');
      
      // Aggiungi paginazione se necessaria
      if (missingMatches.length > MATCHES_PER_PAGE) {
        html += `
          <div class="pagination">
            <button onclick="changeMissingPage(-1)" ${currentMissingPage === 1 ? 'disabled' : ''}>
              â† Prec
            </button>
            <span>Pagina ${currentMissingPage} di ${totalPages} (${missingMatches.length} totali)</span>
            <button onclick="changeMissingPage(1)" ${currentMissingPage === totalPages ? 'disabled' : ''}>
              Succ â†’
            </button>
          </div>
        `;
      }
      
      list.innerHTML = html;
    }
    
    // Cambia pagina partite mancanti
    function changeMissingPage(delta) {
      const totalPages = Math.ceil(missingMatches.length / MATCHES_PER_PAGE);
      currentMissingPage = Math.max(1, Math.min(totalPages, currentMissingPage + delta));
      renderMissingMatches();
      // Scroll to top of missing list
      document.getElementById('missingList').scrollTop = 0;
    }
    
    // Enter key to submit
    document.getElementById('urlInput').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') scrapeMatch();
    });
    
    document.getElementById('modalLinkInput').addEventListener('input', validateModalLink);
    
    // Copy players names to clipboard when clicking on missing match
    function openMissingModal(index) {
      selectedMissingMatch = missingMatches[index];
      if (!selectedMissingMatch) return;
      
      const homeName = selectedMissingMatch.homeTeam?.name || selectedMissingMatch.homeTeam?.shortName || 'TBD';
      const awayName = selectedMissingMatch.awayTeam?.name || selectedMissingMatch.awayTeam?.shortName || 'TBD';
      
      // Crea il testo da copiare: "NomeGiocatore1 vs NomeGiocatore2"
      const textToCopy = `${homeName} vs ${awayName}`;
      
      // Copia negli appunti
      navigator.clipboard.writeText(textToCopy).then(() => {
        // Mostra feedback visivo
        showCopyFeedback(index, textToCopy);
      }).catch(err => {
        console.error('Errore nella copia:', err);
        // Fallback per browser piÃ¹ vecchi
        const textArea = document.createElement('textarea');
        textArea.value = textToCopy;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        showCopyFeedback(index, textToCopy);
      });
    }
    
    // Rimuovi card con animazione quando match viene acquisito
    function removeMatchCardWithAnimation(matchId) {
      console.log('Cerco card con data-match-id:', matchId);
      
      // Prova sia come numero che come stringa
      let card = document.querySelector(`.missing-match-card[data-match-id="${matchId}"]`);
      if (!card) {
        card = document.querySelector(`.missing-match-card[data-match-id="${String(matchId)}"]`);
      }
      
      // Debug: mostra tutti gli ID delle card presenti
      const allCards = document.querySelectorAll('.missing-match-card[data-match-id]');
      console.log('Card presenti:', Array.from(allCards).map(c => c.dataset.matchId));
      
      if (card) {
        console.log('Card trovata, avvio animazione di rimozione');
        
        // Aggiungi classe per animazione
        card.classList.add('removing');
        
        // Rimuovi dalla lista interna dopo l'animazione
        setTimeout(() => {
          // Rimuovi dall'array missingMatches
          const indexToRemove = missingMatches.findIndex(m => 
            String(m.id) === String(matchId)
          );
          
          console.log('Index da rimuovere:', indexToRemove);
          
          if (indexToRemove !== -1) {
            missingMatches.splice(indexToRemove, 1);
          }
          
          // Rimuovi elemento dal DOM
          card.remove();
          
          // Aggiorna contatore e info
          updateMissingCounters();
          
          // Se la pagina Ã¨ vuota e ci sono altre pagine, torna indietro
          const cardsOnPage = document.querySelectorAll('.missing-match-card:not(.removing)').length;
          if (cardsOnPage === 0 && missingMatches.length > 0) {
            currentMissingPage = Math.max(1, currentMissingPage - 1);
            renderMissingMatches();
          }
          
          // Se non ci sono piÃ¹ match, mostra messaggio
          if (missingMatches.length === 0) {
            document.getElementById('missingList').innerHTML = 
              '<div class="loading">Tutte le partite dei tornei recenti sono acquisite!</div>';
          }
        }, 400); // Tempo dell'animazione CSS
        
        // Mostra toast di conferma acquisizione
        showToast('Partita acquisita e rimossa dalla lista');
        
      } else {
        console.log('Card non trovata nel DOM (forse su altra pagina)');
        
        // Se non troviamo la card (magari su altra pagina), aggiorna in background
        const indexToRemove = missingMatches.findIndex(m => 
          String(m.id) === String(matchId)
        );
        
        if (indexToRemove !== -1) {
          console.log('Rimuovo da array interno, index:', indexToRemove);
          missingMatches.splice(indexToRemove, 1);
          updateMissingCounters();
          showToast('Partita acquisita');
        }
      }
    }
    
    // Aggiorna contatori partite mancanti
    function updateMissingCounters() {
      const missingCountBadge = document.getElementById('missingCountBadge');
      const tournamentInfo = document.getElementById('tournamentInfo');
      
      if (missingMatches.length === 0) {
        missingCountBadge.style.display = 'none';
        tournamentInfo.textContent = 'Nessuna partita mancante';
      } else {
        missingCountBadge.textContent = missingMatches.length;
        missingCountBadge.style.display = 'inline-block';
        
        // Aggiorna info tornei
        const tournamentNames = [...new Set(missingMatches.map(m => m.tournamentName).filter(Boolean))];
        tournamentInfo.textContent = `Tornei: ${tournamentNames.join(', ')} - ${missingMatches.length} partite da acquisire`;
      }
      
      // Aggiorna anche la paginazione se presente
      const pagination = document.querySelector('#missingList .pagination span');
      if (pagination) {
        const totalPages = Math.ceil(missingMatches.length / MATCHES_PER_PAGE);
        pagination.textContent = `Pagina ${currentMissingPage} di ${totalPages} (${missingMatches.length} totali)`;
      }
    }
    
    // Mostra feedback visivo dopo la copia
    function showCopyFeedback(index, copiedText) {
      // Trova la card cliccata
      const cards = document.querySelectorAll('.missing-match-card');
      const clickedCard = cards[index % MATCHES_PER_PAGE];
      
      if (clickedCard) {
        // Aggiungi classe per animazione
        clickedCard.classList.add('copied');
        
        // Mostra toast notification
        showToast(`Copiato: ${copiedText}`);
        
        // Rimuovi classe dopo animazione
        setTimeout(() => {
          clickedCard.classList.remove('copied');
        }, 500);
      }
    }
    
    // Toast notification - motion sottile
    function showToast(message) {
      const existingToast = document.querySelector('.copy-toast');
      if (existingToast) existingToast.remove();
      
      const toast = document.createElement('div');
      toast.className = 'copy-toast';
      toast.textContent = message;
      document.body.appendChild(toast);
      
      requestAnimationFrame(() => toast.classList.add('show'));
      
      setTimeout(() => {
        toast.classList.remove('show');
        setTimeout(() => toast.remove(), 200);
      }, 1500);
    }
    
    // Legacy function - kept for compatibility but now just copies
    function openMissingModalLegacy(index) {
      selectedMissingMatch = missingMatches[index];
      if (!selectedMissingMatch) return;
      
      const modal = document.getElementById('linkModal');
      const matchInfo = document.getElementById('modalMatchInfo');
      const linkInput = document.getElementById('modalLinkInput');
      const validation = document.getElementById('modalValidation');
      const submitBtn = document.getElementById('modalSubmitBtn');
      
      const homeName = selectedMissingMatch.homeTeam?.name || 'TBD';
      const awayName = selectedMissingMatch.awayTeam?.name || 'TBD';
      
      matchInfo.innerHTML = `
        <strong>Partita selezionata:</strong><br>
        ${homeName} vs ${awayName}<br>
        <small>ID atteso: ${selectedMissingMatch.id}</small>
      `;
      
      linkInput.value = '';
      validation.innerHTML = '';
      validation.className = 'modal-validation';
      submitBtn.disabled = true;
      
      document.body.classList.add('modal-open');
      modal.style.display = 'flex';
    }
    
    // Close modal
    function closeModal() {
      document.getElementById('linkModal').style.display = 'none';
      document.body.classList.remove('modal-open');
      selectedMissingMatch = null;
    }
    
    // ======== SVG MOMENTUM MODAL ========
    let selectedSvgMatch = null;
    
    // Open SVG Momentum modal for a problematic match
    function openSvgMomentumModal(matchId) {
      const match = allMatchesFromDb.find(m => String(m.id) === String(matchId));
      if (!match) {
        showToast('Match non trovato');
        return;
      }
      
      selectedSvgMatch = match;
      
      const modal = document.getElementById('svgMomentumModal');
      const matchInfo = document.getElementById('svgModalMatchInfo');
      const input = document.getElementById('svgMomentumInput');
      const validation = document.getElementById('svgMomentumValidation');
      const preview = document.getElementById('svgMomentumPreview');
      const submitBtn = document.getElementById('svgMomentumSubmitBtn');
      
      const homeName = getPlayerName(match.home_player);
      const awayName = getPlayerName(match.away_player);
      
      matchInfo.innerHTML = `
        <strong>ðŸ“Š Inserisci Momentum SVG per:</strong><br>
        ${homeName} vs ${awayName}<br>
        <small>Event ID: ${match.id}</small>
      `;
      
      input.value = '';
      validation.innerHTML = '';
      validation.className = 'modal-validation';
      preview.innerHTML = '';
      submitBtn.disabled = true;
      
      // Prevent body scroll
      document.body.classList.add('modal-open');
      modal.style.display = 'flex';
      
      // Focus on textarea
      setTimeout(() => input.focus(), 100);
    }
    
    // Close SVG Momentum modal
    function closeSvgMomentumModal() {
      document.getElementById('svgMomentumModal').style.display = 'none';
      document.body.classList.remove('modal-open');
      selectedSvgMatch = null;
    }
    
    // Validate SVG input and show preview
    function validateSvgMomentum() {
      const input = document.getElementById('svgMomentumInput');
      const validation = document.getElementById('svgMomentumValidation');
      const preview = document.getElementById('svgMomentumPreview');
      const submitBtn = document.getElementById('svgMomentumSubmitBtn');
      const svgHtml = input.value.trim();
      
      if (!svgHtml) {
        validation.innerHTML = '';
        validation.className = 'modal-validation';
        preview.innerHTML = '';
        submitBtn.disabled = true;
        return;
      }
      
      // Count path elements with fill containing home-away
      const pathMatches = svgHtml.match(/<path[^>]*fill="[^"]*home-away[^"]*"[^>]*>/gi) || [];
      const pathCount = pathMatches.length;
      
      if (pathCount === 0) {
        validation.innerHTML = 'âŒ Nessun path SVG valido trovato. Assicurati di copiare i path con fill "home-away-..."';
        validation.className = 'modal-validation error';
        preview.innerHTML = '';
        submitBtn.disabled = true;
        return;
      }
      
      // Count home vs away sides
      let homeCount = 0;
      let awayCount = 0;
      
      pathMatches.forEach(path => {
        // away-primary must be checked first (more specific)
        if (path.includes('away-primary')) {
          awayCount++;
        } else if (path.includes('home-primary')) {
          homeCount++;
        }
      });
      
      // Show preview
      preview.innerHTML = `
        <div class="preview-header">ðŸ“Š Anteprima Estrazione</div>
        <div class="preview-stats">
          <div class="preview-stat">
            <div class="preview-stat-value">${pathCount}</div>
            <div class="preview-stat-label">Games</div>
          </div>
          <div class="preview-stat">
            <div class="preview-stat-value" style="color: #4caf50;">${homeCount}</div>
            <div class="preview-stat-label">Home</div>
          </div>
          <div class="preview-stat">
            <div class="preview-stat-value" style="color: #f44336;">${awayCount}</div>
            <div class="preview-stat-label">Away</div>
          </div>
        </div>
      `;
      
      // Validate game count
      if (pathCount < 6) {
        validation.innerHTML = `âš ï¸ Solo ${pathCount} games rilevati - potrebbero essere insufficienti`;
        validation.className = 'modal-validation warning';
        submitBtn.disabled = false;
      } else {
        validation.innerHTML = `âœ… ${pathCount} games rilevati (${homeCount} home, ${awayCount} away)`;
        validation.className = 'modal-validation success';
        submitBtn.disabled = false;
      }
    }
    
    // Submit SVG Momentum
    async function submitSvgMomentum() {
      const input = document.getElementById('svgMomentumInput');
      const submitBtn = document.getElementById('svgMomentumSubmitBtn');
      const validation = document.getElementById('svgMomentumValidation');
      const svgHtml = input.value.trim();
      
      if (!svgHtml || !selectedSvgMatch) return;
      
      submitBtn.disabled = true;
      submitBtn.innerHTML = '<span class="spinner"></span>Elaborando...';
      
      try {
        const res = await fetch(`${API_BASE}/match/${selectedSvgMatch.id}/momentum-svg`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ svgHtml })
        });
        
        const data = await res.json();
        
        if (res.ok) {
          closeSvgMomentumModal();
          showToast(`âœ… Momentum salvato: ${data.insertedCount || 0} punti`);
          
          // Refresh matches to update completeness
          await loadMatches(true);
          renderProblematicMatches();
        } else {
          validation.innerHTML = `âŒ ${data.error || 'Errore nel salvataggio'}`;
          validation.className = 'modal-validation error';
        }
      } catch (e) {
        validation.innerHTML = `âŒ Errore: ${e.message}`;
        validation.className = 'modal-validation error';
      } finally {
        submitBtn.disabled = false;
        submitBtn.textContent = 'Salva Momentum';
      }
    }
    
    // Event listeners for SVG modal
    document.getElementById('svgMomentumInput').addEventListener('input', validateSvgMomentum);
    document.getElementById('svgMomentumModal').addEventListener('click', (e) => {
      if (e.target.id === 'svgMomentumModal') closeSvgMomentumModal();
    });
    // ======== END SVG MOMENTUM MODAL ========
    
    // Extract event ID from various URL formats
    function extractEventIdFromUrl(url) {
      // Format 1: /event/12345
      let match = url.match(/event\/(\d+)/);
      if (match) return parseInt(match[1]);
      
      // Format 2: #id:12345 (italiano)
      match = url.match(/#id:(\d+)/);
      if (match) return parseInt(match[1]);
      
      // Format 3: #12345
      match = url.match(/#(\d+)$/);
      if (match) return parseInt(match[1]);
      
      // Format 4: ID nel path con slug (es: /cuXbseOId che Ã¨ base36)
      // Cerca pattern alfanumerico seguito da #id:
      match = url.match(/\/([a-zA-Z0-9]+)#id:(\d+)/);
      if (match) return parseInt(match[2]);
      
      return null;
    }
    
    // Validate modal link
    function validateModalLink() {
      const linkInput = document.getElementById('modalLinkInput');
      const validation = document.getElementById('modalValidation');
      const submitBtn = document.getElementById('modalSubmitBtn');
      const url = linkInput.value.trim();
      
      if (!url) {
        validation.innerHTML = '';
        validation.className = 'modal-validation';
        submitBtn.disabled = true;
        return;
      }
      
      // Verifica che sia un URL SofaScore
      if (!url.includes('sofascore.com')) {
        validation.innerHTML = 'âŒ Inserisci un URL di SofaScore';
        validation.className = 'modal-validation error';
        submitBtn.disabled = true;
        return;
      }
      
      // Extract event ID from URL (supporta piÃ¹ formati)
      const eventId = extractEventIdFromUrl(url);
      
      if (!eventId) {
        validation.innerHTML = 'âŒ Impossibile estrarre ID evento dall\'URL';
        validation.className = 'modal-validation error';
        submitBtn.disabled = true;
        return;
      }
      
      const expectedId = selectedMissingMatch?.id;
      
      if (eventId === expectedId) {
        validation.innerHTML = `âœ… Link valido! ID ${eventId} corrisponde`;
        validation.className = 'modal-validation success';
        submitBtn.disabled = false;
      } else {
        validation.innerHTML = `âš ï¸ ID diverso (${eventId} vs atteso ${expectedId}) - Procedi comunque?`;
        validation.className = 'modal-validation warning';
        submitBtn.disabled = false; // Allow anyway but warn
      }
    }
    
    // Submit modal link
    async function submitModalLink() {
      const linkInput = document.getElementById('modalLinkInput');
      const submitBtn = document.getElementById('modalSubmitBtn');
      const url = linkInput.value.trim();
      
      if (!url) return;
      
      submitBtn.disabled = true;
      submitBtn.innerHTML = '<span class="spinner"></span>Acquisendo...';
      
      try {
        const res = await fetch(`${API_BASE}/scrape`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ url })
        });
        
        const data = await res.json();
        
        if (res.ok) {
          closeModal();
          
          // Remove from missing list
          const eventId = extractEventIdFromUrl(url);
          if (eventId) {
            missingMatches = missingMatches.filter(m => m.id !== eventId);
            
            if (missingMatches.length === 0) {
              // No more missing matches - switch to recent tab
              document.getElementById('missingList').innerHTML = '<div class="loading">Tutte le partite del torneo sono state acquisite!</div>';
              document.getElementById('missingCountBadge').style.display = 'none';
              switchTab('recent');
            } else {
              // Update missing matches display
              renderMissingMatches();
            }
          }
          
          // Reload stats and matches (silent)
          currentPage = 1;
          await loadAdvancedStats();
          await loadMatches(true);
        } else {
          const validation = document.getElementById('modalValidation');
          validation.innerHTML = `âŒ ${data.message || 'Errore acquisizione'}`;
          validation.className = 'modal-validation error';
        }
      } catch (e) {
        const validation = document.getElementById('modalValidation');
        validation.innerHTML = `âŒ Errore: ${e.message}`;
        validation.className = 'modal-validation error';
      } finally {
        submitBtn.disabled = false;
        submitBtn.textContent = 'Acquisisci';
      }
    }
    
    // Close modal on outside click
    document.getElementById('linkModal').addEventListener('click', (e) => {
      if (e.target.id === 'linkModal') closeModal();
    });
    
    // Init - carica SOLO i match dal DB, le mancanti solo su richiesta
    async function init() {
      await checkServerStatus();
      await loadAdvancedStats();
      
      // Carica solo match recenti (dal DB, veloce)
      // Le mancanti si caricano solo quando clicchi il tab
      await loadMatches();
      
      // Refresh status ogni 60s (non 30s)
      setInterval(checkServerStatus, 60000);
    }
    
    init();
  </script>
</body>
</html>
