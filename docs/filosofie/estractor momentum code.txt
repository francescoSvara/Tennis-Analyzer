1) Estrarre momentum tennis dal DOM (path d)
function parsePathV(d) {
  // cerca il primo comando verticale "v<number>"
  // esempio: "M1,0 v25.84 h8 v-25.84 z"
  const m = /v\s*([-+]?\d*\.?\d+(?:e[-+]?\d+)?)/i.exec(d);
  if (!m) return null;
  return Number(m[1]);
}

function extractTennisMomentumFromDom(rootEl = document) {
  // ogni svg.set è un set
  const setSvgs = [...rootEl.querySelectorAll('svg.set')];
  if (!setSvgs.length) return { ok: false, reason: 'No svg.set found', sets: [] };

  const sets = setSvgs.map((setSvg, setIndex) => {
    const viewBox = (setSvg.getAttribute('viewBox') || '').trim(); // "0 -40 W 80"
    const vbParts = viewBox ? viewBox.split(/\s+/).map(Number) : null;
    const vbW = vbParts && vbParts.length === 4 ? vbParts[2] : null;

    const games = [...setSvg.querySelectorAll('path.game')].map((p, gameIndex) => {
      const d = p.getAttribute('d') || '';
      const fill = (p.getAttribute('fill') || '').toLowerCase();

      const v = parsePathV(d); // può essere positivo o negativo
      // se non troviamo v, fallback a 0
      const signedRaw = (v == null) ? 0 : v;

      const side =
        fill.includes('home-primary') ? 'home' :
        fill.includes('away-primary') ? 'away' : 'unknown';

      // x lo ricaviamo dall'M iniziale (M<number>,0)
      const mx = /M\s*([-+]?\d*\.?\d+)/i.exec(d);
      const x = mx ? Number(mx[1]) : null;

      const pos01 = (vbW && x != null) ? (x / vbW) : null;

      // signedRaw: teniamo il segno come da SVG (v<0 sopra, v>0 sotto)
      // ma per coerenza semantica, associare segno a side:
      // - home => positivo
      // - away => negativo
      // In pratica: magnitude = abs(v), segno = + per home, - per away
      const magnitude = Math.abs(signedRaw || 0);
      const signedBySide =
        side === 'home' ? +magnitude :
        side === 'away' ? -magnitude :
        signedRaw; // fallback

      return {
        set: setIndex + 1,
        game: gameIndex + 1,
        x,
        pos01,
        side,
        raw_v: signedRaw,         // valore originale v (con segno SVG)
        signed_raw: signedBySide, // valore firmato coerente (home +, away -)
        fill
      };
    });

    return { set: setIndex + 1, viewBox, vbW, games };
  });

  return { ok: true, sets };
}


Uso:

const data = extractTennisMomentumFromDom(document);
console.log(data);
copy(JSON.stringify(data, null, 2));

2) Normalizzazione coerente (-100..+100) per tennis

Qui normalizzi entro ogni set oppure sull’intero match. Ti metto entrambe.

Helper percentile + clamp
function percentile(arr, p) {
  const a = [...arr].sort((x,y)=>x-y);
  if (!a.length) return 0;
  const idx = (a.length - 1) * p;
  const lo = Math.floor(idx), hi = Math.ceil(idx);
  if (lo === hi) return a[lo];
  return a[lo] + (a[hi] - a[lo]) * (idx - lo);
}
function clamp(v, lo, hi) {
  return Math.max(lo, Math.min(hi, v));
}

Normalizza una lista di punti (robusta, percentile 95)
function normalizeSignedSeries(points, {
  field = 'signed_raw',
  pAbs = 0.95,
  outAbs = 100
} = {}) {
  const signed = points.map(p => Number(p[field]) || 0);
  const abs = signed.map(v => Math.abs(v));
  const scale = Math.max(percentile(abs, pAbs), 1e-6);

  return points.map(p => {
    const v = Number(p[field]) || 0;
    const norm = clamp((v / scale) * outAbs, -outAbs, outAbs);
    return { ...p, value: norm, normScale: scale };
  });
}

A) Normalizza per set (consigliato se vuoi confrontare set diversi)
function normalizeTennisMomentumPerSet(extracted) {
  const sets = extracted.sets.map(s => ({
    ...s,
    games: normalizeSignedSeries(s.games, { field: 'signed_raw', pAbs: 0.95, outAbs: 100 })
  }));
  return { ...extracted, sets };
}

B) Normalizza su tutto il match (se vuoi una scala unica)
function normalizeTennisMomentumMatch(extracted) {
  const all = extracted.sets.flatMap(s => s.games);
  const normAll = normalizeSignedSeries(all, { field: 'signed_raw', pAbs: 0.95, outAbs: 100 });

  // rimappa nei set
  let k = 0;
  const sets = extracted.sets.map(s => {
    const games = s.games.map(() => normAll[k++]);
    return { ...s, games };
  });

  return { ...extracted, sets };
}


Uso:

const raw = extractTennisMomentumFromDom(document);
const norm = normalizeTennisMomentumPerSet(raw);   // oppure normalizeTennisMomentumMatch(raw)
console.log(norm);
copy(JSON.stringify(norm, null, 2));

3) Output “powerRankings” pronto per il tuo DB

Se il tuo insertPowerRankings(matchId, powerRankings) vuole { set, game, value }:

function toPowerRankings(normData) {
  const out = [];
  for (const s of normData.sets) {
    for (const g of s.games) {
      out.push({
        set: g.set,
        game: g.game,
        value: g.value,     // -100..+100
        side: g.side,
        x: g.x,
        pos01: g.pos01,
        raw: g.raw_v
      });
    }
  }
  return out;
}

4) Nota sulla “coerenza con JSON API”

Se in passato avevi un JSON tipo tennisPowerRankings[].value:

quello probabilmente era già normalizzato in una certa scala.

con il DOM tu stai prendendo un valore “grafico” (v in unità SVG).

Questa normalizzazione a percentile rende i dati congrui e confrontabili nel tuo sistema.
Se vuoi replicare numericamente la vecchia API (stessa scala identica), ti serve un piccolo dataset di match dove hai sia:

valori API storici

valori DOM estratti
per fare una calibrazione (lineare o piecewise). Ma per analisi/trend in genere non serve.

Ok: allora l’obiettivo è post-match (quando l’API non dà più momentum), e tu vuoi estrarre e salvare la stessa serie che vedi nella pagina per poi farci analisi.

Sì, puoi farlo. Per il post ci sono 3 cose fondamentali da fare bene:

Trovare e caricare la pagina “post” (il widget deve essere renderizzato).

Estrarre dal DOM (nel tennis: <svg class="set"> + <path class="game" d="… v…">).

Normalizzare in modo stabile così i match sono confrontabili.

Qui sotto ti lascio una versione “da progetto” (funzioni pulite) pensata per essere incollata e usata da Copilot.

1) Estrattore tennis post-match (DOM → serie per set/game)
// Estrae il numero del primo comando verticale "v" dal path d
function parseFirstV(d) {
  const m = /v\s*([-+]?\d*\.?\d+(?:e[-+]?\d+)?)/i.exec(d);
  return m ? Number(m[1]) : null;
}

// Estrae la X iniziale dal comando "M<number>,0"
function parseMx(d) {
  const m = /M\s*([-+]?\d*\.?\d+(?:e[-+]?\d+)?)/i.exec(d);
  return m ? Number(m[1]) : null;
}

/**
 * Estrarre momentum tennis dal DOM di SofaScore:
 * - ogni svg.set = un set
 * - ogni path.game = un game (barra)
 * - intensità = abs(v)
 * - segno coerente: home positivo, away negativo (derivato dal fill)
 */
export function extractTennisMomentumFromDocument(root = document) {
  const setSvgs = [...root.querySelectorAll('svg.set')];
  if (!setSvgs.length) {
    return { ok: false, reason: 'No svg.set found (widget not rendered?)', sets: [] };
  }

  const sets = setSvgs.map((setSvg, setIndex) => {
    const viewBox = (setSvg.getAttribute('viewBox') || '').trim(); // es: "0 -40 115.2 80"
    const vbParts = viewBox ? viewBox.split(/\s+/).map(Number) : null;
    const vbW = (vbParts && vbParts.length === 4) ? vbParts[2] : null;

    const games = [...setSvg.querySelectorAll('path.game')]
      .map((p, gameIndex) => {
        const d = p.getAttribute('d') || '';
        const fill = (p.getAttribute('fill') || '').toLowerCase();

        const v = parseFirstV(d) ?? 0;      // v può essere negativo o positivo
        const x = parseMx(d);               // posizione orizzontale nel set
        const pos01 = (vbW && x != null) ? x / vbW : null;

        const side =
          fill.includes('home-primary') ? 'home' :
          fill.includes('away-primary') ? 'away' :
          'unknown';

        const magnitude = Math.abs(v);

        // segno coerente SEMANTICO (indipendente dal verso del path):
        // home = +, away = -
        const signed = side === 'home' ? +magnitude
                     : side === 'away' ? -magnitude
                     : (v || 0);

        return {
          set: setIndex + 1,
          game: gameIndex + 1,
          x,
          pos01,
          side,
          raw_v: v,       // valore grezzo dal path
          signed_raw: signed,
          fill
        };
      });

    return { set: setIndex + 1, viewBox, vbW, games };
  });

  return { ok: true, sets };
}

2) Normalizzazione stabile per analisi post-match

Per analisi “post”, la cosa più importante è comparabilità tra match (non replicare per forza la vecchia scala API).
Questa normalizzazione è robusta (usa percentile 95, evita outlier).

function percentile(arr, p) {
  const a = [...arr].sort((x,y)=>x-y);
  if (!a.length) return 0;
  const idx = (a.length - 1) * p;
  const lo = Math.floor(idx), hi = Math.ceil(idx);
  if (lo === hi) return a[lo];
  return a[lo] + (a[hi] - a[lo]) * (idx - lo);
}

function clamp(v, lo, hi) {
  return Math.max(lo, Math.min(hi, v));
}

/**
 * Normalizza una serie firmata (signed_raw) in -100..+100
 * con scala robusta basata su percentile(|v|).
 */
export function normalizeMomentumSeries(points, {
  signedField = 'signed_raw',
  pAbs = 0.95,
  outAbs = 100
} = {}) {
  const signed = points.map(p => Number(p[signedField]) || 0);
  const abs = signed.map(v => Math.abs(v));
  const scale = Math.max(percentile(abs, pAbs), 1e-6);

  return points.map(p => {
    const v = Number(p[signedField]) || 0;
    return {
      ...p,
      value: clamp((v / scale) * outAbs, -outAbs, outAbs),
      normScale: scale
    };
  });
}

/**
 * Normalizza per set (consigliato nel tennis: set con “dinamiche” diverse)
 */
export function normalizeTennisMomentumPerSet(extracted) {
  return {
    ...extracted,
    sets: extracted.sets.map(s => ({
      ...s,
      games: normalizeMomentumSeries(s.games)
    }))
  };
}

/**
 * Trasforma nel formato "powerRankings" del DB
 */
export function toPowerRankings(normalized) {
  const out = [];
  for (const s of normalized.sets) {
    for (const g of s.games) {
      out.push({
        set: g.set,
        game: g.game,
        value: g.value,
        side: g.side,
        x: g.x,
        pos01: g.pos01,
        raw_v: g.raw_v,
        source: 'sofscore_dom_svg'
      });
    }
  }
  return out;
}

3) Perché questa normalizzazione è “coerente” anche senza API

Nel post-match ti manca il valore “originale API”. Quindi la coerenza che ti serve è:

stessa direzione (chi domina)

stessa forma (spike / trend / volatilità)

scala comparabile tra match

Il percentile scaling ti dà proprio questo.

Se in futuro vuoi allinearti numericamente a una vecchia scala API:

ti basta conservare nel DB anche signed_raw/raw_v

e quando hai un set di match con entrambe le sorgenti (API + DOM), puoi fare una calibrazione (lineare/piecewise) senza perdere nulla.

4) Nota operativa per “post”

Perché funzioni in automatico post-match (Playwright):

devi aspettare che il widget venga renderizzato (selector svg.set path.game)

spesso serve scrollare la pagina fino alla sezione statistiche

Selector utile:

svg.set path.game