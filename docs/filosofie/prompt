
Read server.js lines 3290 to 3550
Il problema Ã¨ nella funzione extractScore. Vediamo cosa fa:

Searched for function extractScore in server.js
Capisco! Il problema Ã¨ che matchData.match.homeScore e awayScore non esistono perchÃ© i dati vengono dal matchCardService.getMatchCardFromSnapshot.

Controllo cosa ritorna quella funzione:

cd "c:\Users\Utente\Desktop\Progetto react sofascore\React-Betfair\backend" ; node -e "const mcs = require('./services/matchCardService'); mcs.getMatchCardFromSnapshot(15255681).then(d => { console.log('Keys:', Object.keys(d || {})); console.log('match.homeScore:', d?.match?.homeScore); console.log('match.sets:', d?.match?.sets); console.log('scoreDetails:', d?.scoreDetails); }).catch(console.error)"
Il match.sets Ã¨ un array vuoto. Il problema Ã¨ nel matchCardService o nella vista/tabella da cui legge i dati.

Controllo come matchCardService costruisce match.sets:

Searched for text in matchCardService.js
Ora controllo formatSets:

Searched for text in matchCardService.js
Il problema Ã¨ chiaro: formatSets legge da match.set1_p1, set1_p2, etc. ma nella tabella matches_new questi campi sono NULL!

I dati dei set sono nella tabella match_scores, non nei campi della tabella matches_new.

Devo modificare matchCardService per leggere i punteggi da match_scores invece che dai campi inline. Ma prima verifico:

Searched for text in matchCardService.js
Il problema Ã¨ duplice:

La funzione getMatchCardFromSnapshot legge da una tabella match_card_snapshot che ha uno snapshot stale
Quando cade back su getMatchCard, usa formatSets che legge da campi set1_p1 etc
La soluzione piÃ¹ pulita Ã¨ modificare la funzione formatSets per leggere i punteggi dalla tabella match_scores SE i campi inline sono NULL.

PerÃ² prima, vediamo dove viene popolato match_card_snapshot e se possiamo aggiornarlo. Alternativamente, modifichiamo il bundle per leggere i set scores separatamente.

La soluzione piÃ¹ diretta: nel bundle, se i sets sono vuoti, leggi da match_scores:

Read server.js, lines 3380 to 3420

Modifico extractScore per caricare i punteggi dei set dalla tabella match_scores se i campi sono vuoti:

Read server.js, lines 3955 to 4030

Il problema Ã¨ che extractScore Ã¨ sincrona e non puÃ² fare query al DB. Devo caricare i dati match_scores nel bundle all'inizio e passarli. Modifico il bundle per caricare match_scores:

Read server.js, lines 3310 to 3350

Aggiungo il caricamento dei match_scores e li uso per arricchire finalMatchData.match.sets:

Edited
server.js+7-2
Ora arricchisco finalMatchData con i set scores dopo aver ottenuto i dati:

Read server.js, lines 3370 to 3395

Edited
server.js+17-2
Ora testiamo il bundle:

cd "c:\Users\Utente\Desktop\Progetto react sofascore\React-Betfair\backend" ; node -e "const http=require('http');http.get('http://localhost:3001/api/match/15255681/bundle',res=>{let d='';res.on('data',c=>d+=c);res.on('end',()=>{const j=JSON.parse(d);console.log('header.score:', JSON.stringify(j.header?.score,null,2)); console.log('\\nBreak games:', j.tabs?.pointByPoint?.games?.filter(g=>g.gameIsBreak)); });})"
Ancora vuoto! Il server non Ã¨ stato riavviato. Devo riavviarlo:

Get-Process -Name "node" -ErrorAction SilentlyContinue | Where-Object {$_.MainWindowTitle -eq '' -and $_.Path -match 'node'} | Stop-Process -Force -ErrorAction SilentlyContinue; cd "c:\Users\Utente\Desktop\Progetto react sofascore\React-Betfair\backend" ; node server.js
Terminal is no longer available.
Start-Sleep -Seconds 3; cd "c:\Users\Utente\Desktop\Progetto react sofascore\React-Betfair\backend" ; node -e "const http=require('http');http.get('http://localhost:3001/api/match/15255681/bundle',res=>{let d='';res.on('data',c=>d+=c);res.on('end',()=>{const j=JSON.parse(d);console.log('header.score:', JSON.stringify(j.header?.score,null,2)); console.log('\\nBreak games:', j.tabs?.pointByPoint?.games?.filter(g=>g.gameIsBreak)); });})"
Terminal is no longer available.
C'Ã¨ un errore. Controllo il log del server:

Checked background terminal output

Il server si Ã¨ avviato e poi si Ã¨ fermato. Riavvio in background:

cd "c:\Users\Utente\Desktop\Progetto react sofascore\React-Betfair\backend" ; node server.js
Start-Sleep -Seconds 2; node -e "const http=require('http');http.get('http://localhost:3001/api/match/15255681/bundle',res=>{let d='';res.on('data',c=>d+=c);res.on('end',()=>{const j=JSON.parse(d);console.log('header.score:', JSON.stringify(j.header?.score,null,2)); console.log('\\nBreak games:', j.tabs?.pointByPoint?.games?.filter(g=>g.gameIsBreak)); });})"
Checked background terminal output

Server attivo! Testo di nuovo:

node -e "const http=require('http');http.get('http://localhost:3001/api/match/15255681/bundle',res=>{let d='';res.on('data',c=>d+=c);res.on('end',()=>{try{const j=JSON.parse(d);console.log('header.score:', JSON.stringify(j.header?.score,null,2)); console.log('\\nBreak games:', j.tabs?.pointByPoint?.games?.filter(g=>g.gameIsBreak));}catch(e){console.error('Parse error:', e.message, d.substring(0,500));} });})"
I punteggi dei set sono ora visibili! ðŸŽ‰

Set 1: 4-3 (tiebreak 7)
Set 2: 4-2
Set 3: 4-1
Ma i break games sono vuoti. Controlliamo perchÃ©. Deve essere un problema nella funzione normalizePointsForBundle:

node -e "const http=require('http');http.get('http://localhost:3001/api/match/15255681/bundle',res=>{let d='';res.on('data',c=>d+=c);res.on('end',()=>{try{const j=JSON.parse(d);const pbp=j.tabs?.pointByPoint;console.log('Points count:', pbp?.points?.length);console.log('Games count:', pbp?.games?.length);console.log('Sample games:', pbp?.games?.slice(0,5).map(g=>({set:g.set,game:g.game,server:g.gameServer,winner:g.gameWinner,break:g.gameIsBreak})));}catch(e){console.error('Error:',e.message);} });})"
Il problema Ã¨ che gameServer Ã¨ "unknown" e gameWinner Ã¨ null. Questo significa che normalizePointsForBundle non sta leggendo i dati serving/scoring correttamente.

Controllo i dati raw dal DB:

cd "c:\Users\Utente\Desktop\Progetto react sofascore\React-Betfair\backend" ; node -e "const {supabase} = require('./db/supabase'); supabase.from('point_by_point').select('set_number, game_number, point_index, serving, scoring').eq('match_id', 15255681).order('set_number').order('game_number').order('point_index').limit(20).then(({data,error})=>{if(error)console.error(error);else console.log(JSON.stringify(data,null,2));})"
I dati serving e scoring sono nel DB! Vedo:

Game 1-1: serving=2, scoring=2 (hold)
Game 1-2: serving=1, scoring=1 (hold)
etc.
Il problema Ã¨ nella funzione normalizePointsForBundle. Controllo cosa ritorna getMatchPointByPoint:

cd "c:\Users\Utente\Desktop\Progetto react sofascore\React-Betfair\backend" ; node -e "const mr = require('./db/matchRepository'); mr.getMatchPointByPoint(15255681, {limit:5}).then(d=>console.log(JSON.stringify(d,null,2))).catch(console.error)"
Ecco! getMatchPointByPoint ritorna server: null e NON include i campi serving/scoring!

Devo controllare la query in getMatchPointByPoint:

Searched for text in matchRepository.js
Vedo! La funzione usa prima match_point_by_point_new e poi point_by_point come fallback. Ma i dati sono nella tabella point_by_point, quindi usa quella. Nella mappatura leggo serving: p.serving ma non c'Ã¨ scoring!

Devo aggiungere scoring alla mappatura:

Edited
matchRepository.js+1-0
Ora controllo normalizePointsForBundle per assicurarmi che legga correttamente:

Read lines 3720 to 3900 in file
La logica Ã¨ corretta. Controllo se p.serving e p.scoring arrivano. Il problema Ã¨ che nella mappatura dentro getMatchPointByPoint ora aggiungo scoring, ma prima mancava. Verifichiamo dopo il riavvio:

Get-Process -Name "node" -ErrorAction SilentlyContinue | Stop-Process -Force -ErrorAction SilentlyContinue
cd "c:\Users\Utente\Desktop\Progetto react sofascore\React-Betfair\backend" ; node server.js
Start-Sleep -Seconds 3; node -e "const http=require('http');http.get('http://localhost:3001/api/match/15255681/bundle',res=>{let d='';res.on('data',c=>d+=c);res.on('end',()=>{try{const j=JSON.parse(d);console.log('Games sample:');j.tabs?.pointByPoint?.games?.slice(0,6).forEach(g=>console.log('Set',g.set,'Game',g.game,'- Server:',g.gameServer,'Winner:',g.gameWinner,'Break:',g.gameIsBreak));}catch(e){console.error('Error:',e.message);}});})"
Nessun output, server potrebbe non essere ancora pronto:

Checked background terminal output

