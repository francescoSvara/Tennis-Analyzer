1) Cosa hai gi√† (riusabile) ‚Äî ‚Äúmattoni backend‚Äù

Dal documento emerge una base solida:

LIVE / Tracking

backend/liveManager.js (polling, reconcile, tracked matches, broadcast) 

MAPPA_RETE_CONCETTUALE

backend/db/liveTrackingRepository.js (CRUD tracking) 

MAPPA_RETE_CONCETTUALE

backend/scraper/sofascoreScraper.js (endpoint SofaScore: event, statistics, power rankings, point-by-point) 

MAPPA_RETE_CONCETTUALE

Pipeline RAW ‚Üí Canonical

backend/services/rawEventsProcessor.js (processRawEvents) 

MAPPA_RETE_CONCETTUALE

backend/services/calculationQueueWorker.js (task async) 

MAPPA_RETE_CONCETTUALE

Metriche/Features (fondamentali per strategie e tabs)

backend/utils/valueInterpreter.js ‚Üí volatility, elasticity, match character, power rankings enhanced 

MAPPA_RETE_CONCETTUALE

backend/utils/pressureCalculator.js ‚Üí pressure index 

MAPPA_RETE_CONCETTUALE

backend/utils/breakDetector.js + server.js calculateBreaksFromPbp (logica break da PbP) 

MAPPA_RETE_CONCETTUALE

backend/utils/matchSegmenter.js (fasi match) 

MAPPA_RETE_CONCETTUALE

SVG fallback momentum: svgMomentumExtractor.js + repo getPowerRankings() con COALESCE(value,value_svg) 

MAPPA_RETE_CONCETTUALE

Assemblaggio ‚Äúcard‚Äù

backend/services/matchCardService.js getMatchCard() + snapshots cache 

MAPPA_RETE_CONCETTUALE


Questo √® perfetto come ‚Äúbase‚Äù per HOME e per l‚Äôheader match.

2) Cosa manca per completare il backend della Match Page

Il tuo documento segnala incongruenze chiave:

frontend fa scraping diretto (INV-002) 

MAPPA_RETE_CONCETTUALE

duplicazione: pressureCalculator backend vs calculatePressureIndex frontend 

MAPPA_RETE_CONCETTUALE

calcoli ‚Äúdata completeness‚Äù nel frontend 

MAPPA_RETE_CONCETTUALE

strategie presenti in FE utils (layTheWinner/superBreak) ma devono stare nel backend per coerenza e per websocket signals 

MAPPA_RETE_CONCETTUALE

üëâ Quindi ti serve un Strategy Engine backend + un Match Aggregation API che fornisca i payload ‚Äúgi√† pronti‚Äù alle tab.

3) Come strutturare backend ‚Äúper pagine‚Äù (e agganci frontend)
3.1 Endpoint minimi (REST) + WS

Questi sono quelli che ti servono per avere tutte le finestre popolabili:

HOME

GET /api/home/live ‚Üí lista match live + mini card + count strategie üü¢/üü°

usa liveManager.fetchLiveList() + matchCardService.getMatchCard()

MATCH (dati base sempre)

GET /api/match/:id/overview ‚Üí scoreboard, odds, quick signals, strategy summary

TAB dedicate (se vuoi payload separati) ‚Äî oppure un endpoint unico ‚Äúbundle‚Äù

GET /api/match/:id/strategies

GET /api/match/:id/odds

GET /api/match/:id/point-by-point

GET /api/match/:id/stats

GET /api/match/:id/momentum

GET /api/match/:id/predictor

GET /api/match/:id/journal

WebSocket (live)

WS /ws/match/:id

push: scoreboard updates, odds updates, pbp event, strategy signals, momentum updates

Scelta pratica: per performance, fai 1 endpoint ‚Äúbundle‚Äù + WS per diff.

GET /api/match/:id/bundle?tabs=overview,strategies,odds,...

4) ‚ÄúQuali funzioni usare‚Äù per generare i dati di ogni tab
A) Overview (operativa)

Backend sources

Score/serve: dal live snapshot o canonical match

Odds: match_odds + live odds feed se c‚Äô√®

Quick signals:

pressure: backend/utils/pressureCalculator.calculatePressureIndex() 

MAPPA_RETE_CONCETTUALE

volatility/elasticity/character: valueInterpreter.* 

MAPPA_RETE_CONCETTUALE

break detection: calculateBreaksFromPbp() o breakDetector 

MAPPA_RETE_CONCETTUALE

Strategy mini panel: vedi sezione Strategy Engine (sotto)

B) Strategie Live (hub)

Qui ti serve un nuovo dominio backend:

Nuovo file consigliato

backend/strategies/strategyEngine.js

registra strategie

riceve matchState normalizzato

emette segnali standardizzati (READY/WATCH/OFF)

Strategie esistenti
Tu hai le funzioni nel doc ‚ÄúStrategie di Base Tennis (codice)‚Äù (lay winner, banca servizio, super break). Quelle vanno portate 1:1 nel backend (o importate come modulo condiviso) e fatte lavorare su matchState normalizzato.

Dipendenze dati per le 3 strategie

Lay Winner: set, winner1set, favorite, odds winner1set

Banca Servizio: servingPlayer + scoreKey + holdDifficulty ‚Äúlast game‚Äù

Super Break: dominantPlayer + dominanceValue + nextToServe + matchType

üëâ quindi backend deve calcolare:

lastGameData.holdDifficulty

dominanceValue (serve dominance)

nextToServe

Queste le ottieni da PbP + stats live (vedi sotto).

C) Odds tab

pre-match: match_odds

live: feed del liveManager (se stai fetchando odds live) o refresh scraper

value/fair odds: filosofia ODDS ‚Üí backend calcola value (il doc suggerisce calcoli odds nel backend, INV-003 warn) 

MAPPA_RETE_CONCETTUALE


Quindi:

nuovo: backend/services/oddsService.js

calculateImpliedProbability()

calculateFairOdds() (usando ranking prob + stats)

detectValueEdge()

D) Point-by-point

fonte: sofascoreScraper /point-by-point + canonical match_point_by_point_new 

MAPPA_RETE_CONCETTUALE

arricchimento:

tag break point / set point / match point

detect break: calculateBreaksFromPbp() 

MAPPA_RETE_CONCETTUALE

E) Stats tab

fonte: match_statistics_new + calcoli dinamici

pressure: pressureCalculator

segmentazione: matchSegmenter.segmentMatch() 

MAPPA_RETE_CONCETTUALE

F) Momentum tab

primary: match_power_rankings_new.value

fallback: value_svg tramite getPowerRankings() (COALESCE) 

MAPPA_RETE_CONCETTUALE

momentum owner/shift: oggi √® nel FE (MomentumTab.jsx analyzeMomentumOwner/detectMomentumShift) 

MAPPA_RETE_CONCETTUALE


üëâ conviene spostarle in:

backend/services/momentumService.js

analyzeMomentumOwner()

detectMomentumShift()

G) Predictor tab

modello semplice (non ML) ma utile:

winProb live

break next game prob

edge vs mercato

driver: stats + momentum + pressure + player stats

Backend riuso:

playerStatsService.getPlayerStats() + comeback rate + ROI 

MAPPA_RETE_CONCETTUALE

valueInterpreter per volatility/elasticity

oddsService per implied prob

Nuovo:

backend/services/predictorService.js

computeWinProbability(matchState, stats, momentum, playerStats)

computeBreakNextGameProbability(...)

computeEdgeVsMarket(...)

H) Journal tab

nuovo dominio:

tabella trades o strategy_actions (se non c‚Äô√® gi√†)

endpoints:

POST /api/match/:id/trade

GET /api/match/:id/journal

auto-log da frontend quando clicca CTA, oppure da backend se ricevi ‚Äúaction executed‚Äù.

5) Il documento ‚Äúbackend allacci‚Äù che ti conviene creare (struttura)

Tu vuoi: ‚Äú1 doc frontend visivo‚Äù + ‚Äú1 doc backend allacci‚Äù.

Ecco l‚Äôindice perfetto del doc backend:

BACKEND_MATCH_PAGE_SPEC.md
1) MatchState Schema (canonical)
2) Endpoints (REST + WS)
3) Tab Payload Contracts (Overview/Strategies/Odds/PbP/Stats/Momentum/Predictor/Journal)
4) Strategy Engine (interface + strategy list)
5) Services map (chi calcola cosa)
6) Data sources (DB tables + SofaScore endpoints)
7) Caching & snapshot rules
8) Guardrails (cooldown, anti-flap, data completeness)

6) Spostamenti obbligati (per rendere tutto coerente)

Dal tuo stesso report:

‚ùå FE scraping ‚Üí ‚úÖ solo backend 

MAPPA_RETE_CONCETTUALE

‚ùå duplicazione pressure calcs ‚Üí ‚úÖ pressure calcolato backend e FE solo render 

MAPPA_RETE_CONCETTUALE

‚ùå strategie in FE utils ‚Üí ‚úÖ strategy engine backend, FE consuma segnali 

MAPPA_RETE_CONCETTUALE

‚ùå data completeness in FE ‚Üí ‚úÖ backend calcola completeness e manda badge